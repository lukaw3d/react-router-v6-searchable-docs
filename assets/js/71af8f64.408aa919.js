"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5926],{3222:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var a=n(5893),o=n(1151);const r={title:"Deferred Data",description:"When, why, and how to defer non-critical data loading with React 18 and React Router's defer API.",new:!0,sidebar_position:void 0},s="Deferred Data Guide",i={id:"guides/deferred",title:"Deferred Data",description:"When, why, and how to defer non-critical data loading with React 18 and React Router's defer API.",source:"@site/react-router/docs/guides/deferred.md",sourceDirName:"guides",slug:"/guides/deferred",permalink:"/react-router-v6-searchable-docs/guides/deferred",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1680703145,formattedLastUpdatedAt:"Apr 5, 2023",frontMatter:{title:"Deferred Data",description:"When, why, and how to defer non-critical data loading with React 18 and React Router's defer API.",new:!0},sidebar:"tutorialSidebar",previous:{title:"Data Synchronization",permalink:"/react-router-v6-searchable-docs/guides/data"},next:{title:"Working With FormData",permalink:"/react-router-v6-searchable-docs/guides/form-data"}},d={},c=[{value:"The problem",id:"the-problem",level:2},{value:"The solution",id:"the-solution",level:2},{value:"Using <code>defer</code>",id:"using-defer",level:3},{value:"Evaluating the solution",id:"evaluating-the-solution",level:2},{value:"FAQ",id:"faq",level:2},{value:"Why not defer everything by default?",id:"why-not-defer-everything-by-default",level:3},{value:"When does the <code>&lt;Suspense/&gt;</code> fallback render?",id:"when-does-the-suspense-fallback-render",level:3},{value:"Why don&#39;t Response objects returned by the loader work anymore?",id:"why-dont-response-objects-returned-by-the-loader-work-anymore",level:3}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"deferred-data-guide",children:"Deferred Data Guide"}),"\n",(0,a.jsx)(t.h2,{id:"the-problem",children:"The problem"}),"\n",(0,a.jsx)(t.p,{children:"Imagine a scenario where one of your routes' loaders needs to retrieve some data that for one reason or another is quite slow. For example, let's say you're showing the user the location of a package that's being delivered to their home:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:'import { json, useLoaderData } from "react-router-dom";\nimport { getPackageLocation } from "./api/packages";\n\nasync function loader({ params }) {\n  const packageLocation = await getPackageLocation(\n    params.packageId\n  );\n\n  return json({ packageLocation });\n}\n\nfunction PackageRoute() {\n  const data = useLoaderData();\n  const { packageLocation } = data;\n\n  return (\n    <main>\n      <h1>Let\'s locate your package</h1>\n      <p>\n        Your package is at {packageLocation.latitude} lat\n        and {packageLocation.longitude} long.\n      </p>\n    </main>\n  );\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["We'll assume that ",(0,a.jsx)(t.code,{children:"getPackageLocation"})," is slow. This will lead to initial page load times and transitions to that route to take as long as the slowest bit of data. There are a few things you can do to optimize this and improve the user experience:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Speed up the slow thing (\ud83d\ude05)."}),"\n",(0,a.jsxs)(t.li,{children:["Parallelize data loading with ",(0,a.jsx)(t.code,{children:"Promise.all"})," (we have nothing to parallelize in our example, but it might help a bit in other situations)."]}),"\n",(0,a.jsx)(t.li,{children:"Add a global transition spinner (helps a bit with UX)."}),"\n",(0,a.jsx)(t.li,{children:"Add a localized skeleton UI (helps a bit with UX)."}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["If these approaches don't work well, then you may feel forced to move the slow data out of the ",(0,a.jsx)(t.code,{children:"loader"})," into a component fetch (and show a skeleton fallback UI while loading). In this case you'd render the fallback UI on mount and fire off the fetch for the data. This is actually not so terrible from a DX standpoint thanks to ",(0,a.jsx)(t.a,{href:"../hooks/use-fetcher",children:(0,a.jsx)(t.code,{children:"useFetcher"})}),". And from a UX standpoint this improves the loading experience for both client-side transitions as well as initial page load. So it does seem to solve the problem."]}),"\n",(0,a.jsx)(t.p,{children:"But it's still sub optimal in most cases (especially if you're code-splitting route components) for two reasons:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"Client-side fetching puts your data request on a waterfall: document -> JavaScript -> Lazy Loaded Route -> data fetch"}),"\n",(0,a.jsx)(t.li,{children:"Your code can't easily switch between component fetching and route fetching (more on this later)."}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"the-solution",children:"The solution"}),"\n",(0,a.jsxs)(t.p,{children:["React Router takes advantage of React 18's Suspense for data fetching using the ",(0,a.jsxs)(t.a,{href:"../utils/defer",children:[(0,a.jsx)(t.code,{children:"defer"})," Response"]})," utility and ",(0,a.jsx)(t.a,{href:"../components/await",children:(0,a.jsx)(t.code,{children:"<Await />"})})," component / ",(0,a.jsx)(t.a,{href:"../hooks/use-async-value",children:(0,a.jsx)(t.code,{children:"useAsyncValue"})})," hook. By using these APIs, you can solve both of these problems:"]}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"Your data is no longer on a waterfall: document -> JavaScript -> Lazy Loaded Route & data (in parallel)"}),"\n",(0,a.jsx)(t.li,{children:"Your code can easily switch between rendering the fallback and waiting for the data"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Let's take a dive into how to accomplish this."}),"\n",(0,a.jsxs)(t.h3,{id:"using-defer",children:["Using ",(0,a.jsx)(t.code,{children:"defer"})]}),"\n",(0,a.jsxs)(t.p,{children:["Start by adding ",(0,a.jsx)(t.code,{children:"<Await />"})," for your slow data requests where you'd rather render a fallback UI. Let's do that for our example above:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",metastring:"lines=[3,9,13-15,24-40]",children:'import {\n  Await,\n  defer,\n  useLoaderData,\n} from "react-router-dom";\nimport { getPackageLocation } from "./api/packages";\n\nasync function loader({ params }) {\n  const packageLocationPromise = getPackageLocation(\n    params.packageId\n  );\n\n  return defer({\n    packageLocation: packageLocationPromise,\n  });\n}\n\nexport default function PackageRoute() {\n  const data = useLoaderData();\n\n  return (\n    <main>\n      <h1>Let\'s locate your package</h1>\n      <React.Suspense\n        fallback={<p>Loading package location...</p>}\n      >\n        <Await\n          resolve={data.packageLocation}\n          errorElement={\n            <p>Error loading package location!</p>\n          }\n        >\n          {(packageLocation) => (\n            <p>\n              Your package is at {packageLocation.latitude}{" "}\n              lat and {packageLocation.longitude} long.\n            </p>\n          )}\n        </Await>\n      </React.Suspense>\n    </main>\n  );\n}\n'})}),"\n",(0,a.jsxs)(n,{children:[(0,a.jsxs)("summary",{children:["Alternatively, you can use the ",(0,a.jsx)(t.code,{children:"useAsyncValue"})," hook:"]}),(0,a.jsx)(t.p,{children:"If you're not jazzed about bringing back render props, you can use a hook, but you'll have to break things out into another component:"}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",metastring:"lines=[11, 16, 23-31]",children:'export default function PackageRoute() {\n  const data = useLoaderData();\n\n  return (\n    <main>\n      <h1>Let\'s locate your package</h1>\n      <React.Suspense\n        fallback={<p>Loading package location...</p>}\n      >\n        <Await\n          resolve={data.packageLocation}\n          errorElement={\n            <p>Error loading package location!</p>\n          }\n        >\n          <PackageLocation />\n        </Await>\n      </React.Suspense>\n    </main>\n  );\n}\n\nfunction PackageLocation() {\n  const packageLocation = useAsyncValue();\n  return (\n    <p>\n      Your package is at {packageLocation.latitude} lat and{" "}\n      {packageLocation.longitude} long.\n    </p>\n  );\n}\n'})})]}),"\n",(0,a.jsx)(t.h2,{id:"evaluating-the-solution",children:"Evaluating the solution"}),"\n",(0,a.jsx)(t.p,{children:"So rather than waiting for the component before we can trigger the fetch request, we start the request for the slow data as soon as the user starts the transition to the new route. This can significantly speed up the user experience for slower networks."}),"\n",(0,a.jsxs)(t.p,{children:["Additionally, the API that React Router exposes for this is extremely ergonomic. You can literally switch between whether something is going to be deferred or not based on whether you include the ",(0,a.jsx)(t.code,{children:"await"})," keyword:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-tsx",children:"return defer({\n  // not deferred:\n  packageLocation: await packageLocationPromise,\n  // deferred:\n  packageLocation: packageLocationPromise,\n});\n"})}),"\n",(0,a.jsx)(t.p,{children:"Because of this, you can A/B test deferring, or even determine whether to defer based on the user or data being requested:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-tsx",children:"async function loader({ request, params }) {\n  const packageLocationPromise = getPackageLocation(\n    params.packageId\n  );\n  const shouldDefer = shouldDeferPackageLocation(\n    request,\n    params.packageId\n  );\n\n  return defer({\n    packageLocation: shouldDefer\n      ? packageLocationPromise\n      : await packageLocationPromise,\n  });\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["That ",(0,a.jsx)(t.code,{children:"shouldDeferPackageLocation"})," could be implemented to check the user making the request, whether the package location data is in a cache, the status of an A/B test, or whatever else you want. This is pretty sweet \ud83c\udf6d"]}),"\n",(0,a.jsx)(t.h2,{id:"faq",children:"FAQ"}),"\n",(0,a.jsx)(t.h3,{id:"why-not-defer-everything-by-default",children:"Why not defer everything by default?"}),"\n",(0,a.jsx)(t.p,{children:"The React Router defer API is another lever React Router offers to give you a nice way to choose between trade-offs. Do you want the page to render more quickly? Defer stuff. Do you want a lower CLS (Content Layout Shift)? Don't defer stuff. You want a faster render, but also want a lower CLS? Defer just the slow and unimportant stuff."}),"\n",(0,a.jsx)(t.p,{children:"It's all trade-offs, and what's neat about the API design is that it's well suited for you to do easy experimentation to see which trade-offs lead to better results for your real-world key indicators."}),"\n",(0,a.jsxs)(t.h3,{id:"when-does-the-suspense-fallback-render",children:["When does the ",(0,a.jsx)(t.code,{children:"<Suspense/>"})," fallback render?"]}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"<Await />"})," component will only throw the promise up the ",(0,a.jsx)(t.code,{children:"<Suspense>"})," boundary on the initial render of the ",(0,a.jsx)(t.code,{children:"<Await />"})," component with an unsettled promise. It will not re-render the fallback if props change. Effectively, this means that you ",(0,a.jsx)(t.em,{children:"will not"})," get a fallback rendered when a user submits a form and loader data is revalidated. You ",(0,a.jsx)(t.em,{children:"will"})," get a fallback rendered when the user navigates to the same route with different params (in the context of our above example, if the user selects from a list of packages on the left to find their location on the right)."]}),"\n",(0,a.jsx)(t.p,{children:"This may feel counter-intuitive at first, but stay with us, we really thought this through and it's important that it works this way. Let's imagine a world without the deferred API. For those scenarios you're probably going to want to implement Optimistic UI for form submissions/revalidation."}),"\n",(0,a.jsxs)(t.p,{children:["When you decide you'd like to try the trade-offs of ",(0,a.jsx)(t.code,{children:"defer"}),", we don't want you to have to change or remove those optimizations because we want you to be able to easily switch between deferring some data and not deferring it. So, we ensure that your existing optimistic states work the same way. If we didn't do this, then you could experience what we call \"Popcorn UI\" where submissions of data trigger the fallback loading state instead of the optimistic UI you'd worked hard on."]}),"\n",(0,a.jsxs)(t.p,{children:["So just keep this in mind: ",(0,a.jsx)(t.strong,{children:"Deferred is 100% only about the initial load of a route and its params."})]}),"\n",(0,a.jsx)(t.h3,{id:"why-dont-response-objects-returned-by-the-loader-work-anymore",children:"Why don't Response objects returned by the loader work anymore?"}),"\n",(0,a.jsxs)(t.p,{children:["When you use ",(0,a.jsx)(t.code,{children:"defer"}),", you're telling React Router to load the page immediately, without the deferred data. The page is already loaded before the ",(0,a.jsx)(t.code,{children:"Response"})," object is returned so responses are not automatically processed in the same way as if you had done ",(0,a.jsx)(t.code,{children:"return fetch(url)"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["Therefore, you will need to handle your own ",(0,a.jsx)(t.code,{children:"Response"})," processing and resolve your deferred Promise with data, not a ",(0,a.jsx)(t.code,{children:"Response"})," instance."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:"async function loader({ request, params }) {\n  return defer({\n    // Broken! Resolves with a Response\n    // broken: fetch(url),\n\n    // Fixed! Resolves with the response data\n    data: fetch(url).then((res) => res.json()),\n  });\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Or consider the scenario where our deferred data could return a redirect ",(0,a.jsx)(t.code,{children:"Response"}),". You can detect the redirect and send the status code and location back as data, and then you could perform a client-side redirect in your component via ",(0,a.jsx)(t.code,{children:"useEffect"})," and ",(0,a.jsx)(t.code,{children:"useNavigate"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:'async function loader({ request, params }) {\n  let data = fetch(url).then((res) => {\n    if (res.status == 301) {\n      return {\n        isRedirect: true,\n        status: res.status,\n        location: res.headers.get("Location"),\n      };\n    }\n    return res.json();\n  });\n\n  return defer({ data });\n}\n'})})]})}function h(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>s});var a=n(7294);const o={},r=a.createContext(o);function s(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);