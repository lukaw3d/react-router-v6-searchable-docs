"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5031],{9875:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>l,frontMatter:()=>a,metadata:()=>d,toc:()=>i});var o=r(5893),n=r(1151);const a={title:"useLoaderData",new:!0,sidebar_position:void 0},s="useLoaderData",d={id:"hooks/use-loader-data",title:"useLoaderData",description:"This hook provides the value returned from your route loader.",source:"@site/react-router/docs/hooks/use-loader-data.md",sourceDirName:"hooks",slug:"/hooks/use-loader-data",permalink:"/react-router-v6-searchable-docs/hooks/use-loader-data",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1662745445,formattedLastUpdatedAt:"Sep 9, 2022",frontMatter:{title:"useLoaderData",new:!0},sidebar:"tutorialSidebar",previous:{title:"useLinkPressHandler",permalink:"/react-router-v6-searchable-docs/hooks/use-link-press-handler"},next:{title:"useLocation",permalink:"/react-router-v6-searchable-docs/hooks/use-location"}},c={},i=[];function u(e){const t={a:"a",code:"code",em:"em",h1:"h1",p:"p",pre:"pre",...(0,n.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"useloaderdata",children:(0,o.jsx)(t.code,{children:"useLoaderData"})}),"\n",(0,o.jsx)(t.p,{children:"This hook provides the value returned from your route loader."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",metastring:"lines=[4,12]",children:'import {\n  createBrowserRouter,\n  RouterProvider,\n  useLoaderData,\n} from "react-router-dom";\n\nfunction loader() {\n  return fetchFakeAlbums();\n}\n\nexport function Albums() {\n  const albums = useLoaderData();\n  // ...\n}\n\nconst router = createBrowserRouter([\n  {\n    path: "/",\n    loader: loader,\n    element: <Albums />,\n  },\n]);\n\nReactDOM.createRoot(el).render(\n  <RouterProvider router={router} />\n);\n'})}),"\n",(0,o.jsxs)(t.p,{children:["After route ",(0,o.jsx)(t.a,{href:"../components/route#action",children:"actions"})," are called, the data will be revalidated automatically and return the latest result from your loader."]}),"\n",(0,o.jsxs)(t.p,{children:["Note that ",(0,o.jsx)(t.code,{children:"useLoaderData"})," ",(0,o.jsx)(t.em,{children:"does not initiate a fetch"}),". It simply reads the result of a fetch React Router manages internally, so you don't need to worry about it refetching when it re-renders for reasons outside of routing."]}),"\n",(0,o.jsxs)(t.p,{children:["This also means data returned is stable between renders, so you can safely pass it to dependency arrays in React hooks like ",(0,o.jsx)(t.code,{children:"useEffect"}),". It only changes when the loader is called again after actions or certain navigations. In these cases the identity will change (even if the values don't)."]}),"\n",(0,o.jsx)(t.p,{children:"You can use this hook in any component or any custom hook, not just the Route element. It will return the data from the nearest route on context."}),"\n",(0,o.jsxs)(t.p,{children:["To get data from any active route on the page, see ",(0,o.jsx)(t.a,{href:"./use-route-loader-data",children:(0,o.jsx)(t.code,{children:"useRouteLoaderData"})}),"."]})]})}function l(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},1151:(e,t,r)=>{r.d(t,{Z:()=>d,a:()=>s});var o=r(7294);const n={},a=o.createContext(n);function s(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);