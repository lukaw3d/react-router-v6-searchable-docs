"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7472],{188:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>c,toc:()=>i});var n=r(5893),o=r(1151);const s={title:"createStaticHandler",new:!0,sidebar_position:void 0},a="createStaticHandler",c={id:"routers/create-static-handler",title:"createStaticHandler",description:"createStaticHandler is used to perform the data fetching and submissions on the server (i.e., Node or another Javascript runtime) prior to server-side rendering your application via ``. For a more complete overview, please refer to the Server-Side Rendering guide.",source:"@site/react-router/docs/routers/create-static-handler.md",sourceDirName:"routers",slug:"/routers/create-static-handler",permalink:"/react-router-v6-searchable-docs/routers/create-static-handler",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1682609654,formattedLastUpdatedAt:"Apr 27, 2023",frontMatter:{title:"createStaticHandler",new:!0},sidebar:"tutorialSidebar",previous:{title:"createMemoryRouter",permalink:"/react-router-v6-searchable-docs/routers/create-memory-router"},next:{title:"createStaticRouter",permalink:"/react-router-v6-searchable-docs/routers/create-static-router"}},d={},i=[{value:"Type Declaration",id:"type-declaration",level:2},{value:"<code>routes</code>/<code>basename</code>",id:"routesbasename",level:2},{value:"<code>handler.query(request, opts)</code>",id:"handlerqueryrequest-opts",level:2},{value:"<code>opts.requestContext</code>",id:"optsrequestcontext",level:3},{value:"<code>handler.queryRoute(request, opts)</code>",id:"handlerqueryrouterequest-opts",level:2},{value:"<code>opts.routeId</code>",id:"optsrouteid",level:3},{value:"<code>opts.requestContext</code>",id:"optsrequestcontext-1",level:3}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"createstatichandler",children:(0,n.jsx)(t.code,{children:"createStaticHandler"})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"createStaticHandler"})," is used to perform the data fetching and submissions on the server (i.e., ",(0,n.jsx)(t.a,{href:"https://nodejs.org/",children:"Node"})," or another Javascript runtime) prior to server-side rendering your application via ",(0,n.jsx)(t.code,{children:"<StaticRouterProvider>"}),". For a more complete overview, please refer to the ",(0,n.jsx)(t.a,{href:"../guides/ssr",children:"Server-Side Rendering"})," guide."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-jsx",metastring:"lines=[2,21-23]",children:'import {\n  createStaticHandler,\n  createStaticRouter,\n  StaticRouterProvider,\n} from "react-router-dom/server";\nimport Root, {\n  loader as rootLoader,\n  ErrorBoundary as RootBoundary,\n} from "./root";\n\nconst routes = [\n  {\n    path: "/",\n    loader: rootLoader,\n    Component: Root,\n    ErrorBoundary: RootBoundary,\n  },\n];\n\nexport async function renderHtml(req) {\n  let { query, dataRoutes } = createStaticHandler(routes);\n  let fetchRequest = createFetchRequest(req);\n  let context = await query(fetchRequest);\n\n  // If we got a redirect response, short circuit and let our Express server\n  // handle that directly\n  if (context instanceof Response) {\n    throw context;\n  }\n\n  let router = createStaticRouter(dataRoutes, context);\n  return ReactDOMServer.renderToString(\n    <React.StrictMode>\n      <StaticRouterProvider\n        router={router}\n        context={context}\n      />\n    </React.StrictMode>\n  );\n}\n'})}),"\n",(0,n.jsx)(t.h2,{id:"type-declaration",children:"Type Declaration"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"declare function createStaticHandler(\n  routes: RouteObject[],\n  opts?: {\n    basename?: string;\n  }\n): StaticHandler;\n\ninterface StaticHandler {\n  dataRoutes: AgnosticDataRouteObject[];\n  query(\n    request: Request,\n    opts?: {\n      requestContext?: unknown;\n    }\n  ): Promise<StaticHandlerContext | Response>;\n  queryRoute(\n    request: Request,\n    opts?: {\n      routeId?: string;\n      requestContext?: unknown;\n    }\n  ): Promise<any>;\n}\n"})}),"\n",(0,n.jsxs)(t.h2,{id:"routesbasename",children:[(0,n.jsx)(t.code,{children:"routes"}),"/",(0,n.jsx)(t.code,{children:"basename"})]}),"\n",(0,n.jsxs)(t.p,{children:["These are the same ",(0,n.jsx)(t.code,{children:"routes"}),"/",(0,n.jsx)(t.code,{children:"basename"})," you would pass to ",(0,n.jsx)(t.a,{href:"./create-browser-router",children:(0,n.jsx)(t.code,{children:"createBrowserRouter"})})]}),"\n",(0,n.jsx)(t.h2,{id:"handlerqueryrequest-opts",children:(0,n.jsx)(t.code,{children:"handler.query(request, opts)"})}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"handler.query()"})," method takes in a Fetch request, performs route matching, and executes all relevant route action/loader methods depending on the request. The return ",(0,n.jsx)(t.code,{children:"context"})," value contains all of the information required to render the HTML document for the request (route-level ",(0,n.jsx)(t.code,{children:"actionData"}),", ",(0,n.jsx)(t.code,{children:"loaderData"}),", ",(0,n.jsx)(t.code,{children:"errors"}),", etc.). If any of the matched routes return or throw a redirect response, then ",(0,n.jsx)(t.code,{children:"query()"})," will return that redirect in the form of Fetch ",(0,n.jsx)(t.code,{children:"Response"}),"."]}),"\n",(0,n.jsx)(t.h3,{id:"optsrequestcontext",children:(0,n.jsx)(t.code,{children:"opts.requestContext"})}),"\n",(0,n.jsxs)(t.p,{children:["If you need to pass information from your server into Remix actions/loaders, you can do so with ",(0,n.jsx)(t.code,{children:"opts.requestContext"})," and it will show up in your actions/loaders in the context parameter."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"const routes = [{\n  path: '/',\n  loader({ request, context }) {\n    // Access `context.dataFormExpressMiddleware` here\n  },\n}];\n\nexport async function render(req: express.Request) {\n  let { query, dataRoutes } = createStaticHandler(routes);\n  let remixRequest = createFetchRequest(request);\n  let staticHandlerContext = await query(remixRequest, {\n    // Pass data from the express layer to the remix layer here\n    requestContext: {\n      dataFromExpressMiddleware: req.something\n    }\n });\n ...\n}\n"})}),"\n",(0,n.jsx)(t.h2,{id:"handlerqueryrouterequest-opts",children:(0,n.jsx)(t.code,{children:"handler.queryRoute(request, opts)"})}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"handler.queryRoute"})," is a more-targeted version that queries a singular route and runs it's loader or action based on the request. By default, it will match the target route based on the request URL. The return value is the values returned from the loader or action, which is usually a ",(0,n.jsx)(t.code,{children:"Response"})," object."]}),"\n",(0,n.jsx)(t.h3,{id:"optsrouteid",children:(0,n.jsx)(t.code,{children:"opts.routeId"})}),"\n",(0,n.jsxs)(t.p,{children:["If you need to call a specific route action/loader that doesn't exactly correspond to the URL (for example, a parent route loader), you can specify a ",(0,n.jsx)(t.code,{children:"routeId"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:'staticHandler.queryRoute(new Request("/parent/child"), {\n  routeId: "parent",\n});\n'})}),"\n",(0,n.jsx)(t.h3,{id:"optsrequestcontext-1",children:(0,n.jsx)(t.code,{children:"opts.requestContext"})}),"\n",(0,n.jsxs)(t.p,{children:["If you need to pass information from your server into Remix actions/loaders, you can do so with ",(0,n.jsx)(t.code,{children:"opts.requestContext"})," and it will show up in your actions/loaders in the context parameter. See the example in the ",(0,n.jsx)(t.code,{children:"query()"})," section above."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"See also:"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"../routers/create-static-router",children:(0,n.jsx)(t.code,{children:"createStaticRouter"})})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"../routers/static-router-provider",children:(0,n.jsx)(t.code,{children:"<StaticRouterProvider>"})})}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},1151:(e,t,r)=>{r.d(t,{Z:()=>c,a:()=>a});var n=r(7294);const o={},s=n.createContext(o);function a(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);