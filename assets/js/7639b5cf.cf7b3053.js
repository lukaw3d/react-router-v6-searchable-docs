"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3059],{3314:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var n=a(5893),r=a(1151);const o={title:"Data Library Integration",description:'Since the release of v6.4 some folks wonder if React Router is attempting to replace libraries like React Query.  The answer is "nope!".',sidebar_position:void 0},i="Data Library Integration",s={id:"guides/data-libs",title:"Data Library Integration",description:'Since the release of v6.4 some folks wonder if React Router is attempting to replace libraries like React Query.  The answer is "nope!".',source:"@site/react-router/docs/guides/data-libs.md",sourceDirName:"guides",slug:"/guides/data-libs",permalink:"/react-router-v6-searchable-docs/guides/data-libs",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1663953635,formattedLastUpdatedAt:"Sep 23, 2022",frontMatter:{title:"Data Library Integration",description:'Since the release of v6.4 some folks wonder if React Router is attempting to replace libraries like React Query.  The answer is "nope!".'},sidebar:"tutorialSidebar",previous:{title:"Code Splitting",permalink:"/react-router-v6-searchable-docs/guides/code-splitting"},next:{title:"Data Synchronization",permalink:"/react-router-v6-searchable-docs/guides/data"}},c={},d=[{value:"Loading Data",id:"loading-data",level:2},{value:"Accessing Data in Components",id:"accessing-data-in-components",level:2},{value:"Invalidating Data in Mutations",id:"invalidating-data-in-mutations",level:2},{value:"Usage with <code>defer</code>",id:"usage-with-defer",level:2},{value:"The Overlap",id:"the-overlap",level:2},{value:"Conclusion",id:"conclusion",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"data-library-integration",children:"Data Library Integration"}),"\n",(0,n.jsxs)(t.p,{children:["Since the release of v6.4 some folks wonder if React Router is attempting to replace libraries like ",(0,n.jsx)(t.a,{href:"https://tanstack.com/query/v4/",children:"React Query"}),", ",(0,n.jsx)(t.a,{href:"https://swr.vercel.app/",children:"useSwr"}),", etc."]}),"\n",(0,n.jsx)(t.p,{children:'The answer is "nope!".'}),"\n",(0,n.jsxs)(t.p,{children:["React Router's data APIs are about ",(0,n.jsx)(t.em,{children:"when"})," to load, mutate, and revalidate data, but not ",(0,n.jsx)(t.em,{children:"how"})," to do it. It's about the data lifecycle, not the actual implementation of data fetching, mutation, storage, and caching."]}),"\n",(0,n.jsxs)(t.p,{children:["Considering that ",(0,n.jsx)(t.code,{children:"<a href>"})," and ",(0,n.jsx)(t.code,{children:"<form action>"})," are both navigation events, and both coupled to data (what data to show or what data to change), it makes sense that a client side router would help you with the ",(0,n.jsx)(t.em,{children:"navigation state"})," of both elements. But the actual data implementation is up to you."]}),"\n",(0,n.jsxs)(t.p,{children:["The examples here were adapted from ",(0,n.jsx)(t.a,{href:"https://tkdodo.eu/blog/react-query-meets-react-router",children:"TkDodo's blog"}),", thank you for the great post!"]}),"\n",(0,n.jsx)(t.h2,{id:"loading-data",children:"Loading Data"}),"\n",(0,n.jsxs)(t.p,{children:["Instead of loading data in components, you use your data abstractions inside of loaders. Note that this loading happens outside of the React render lifecycle, so you can't use hooks like React Query's ",(0,n.jsx)(t.code,{children:"useQuery"}),", you'll need to use the query client's methods directly."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-jsx",metastring:"lines=[4]",children:'import { queryClient } from "./query-client";\n\nexport const loader = ({ params }) => {\n  return queryClient.fetchQuery(queryKey, queryFn, {\n    staleTime: 10000,\n  });\n};\n'})}),"\n",(0,n.jsxs)(t.p,{children:["If the query client throws errors correctly, then React Router's ",(0,n.jsx)(t.a,{href:"../route/error-element",children:(0,n.jsx)(t.code,{children:"errorElement"})})," will work the same."]}),"\n",(0,n.jsx)(t.p,{children:"Of course, you can use all of the features of the data library, like caching. Caching your data ensures that when the user clicks the back button to a page you've already seen, the data is loaded from the cache immediately. Sometimes caching is the right choice, sometimes you always want it fresh, but that's not a decision within the scope of React Router's data APIs."}),"\n",(0,n.jsxs)(t.p,{children:["React Router only retains the ",(0,n.jsx)(t.em,{children:"current page's loaderData"}),'. If users click "back", all loaders are called again. Without a data caching library like React Query (or HTTP cache headers on your JSON API to use the browser\'s own HTTP cache), your app will refetch all of the data again.']}),"\n",(0,n.jsxs)(t.p,{children:["In this way, React Router is about ",(0,n.jsx)(t.em,{children:"timing"}),", where React Query is about ",(0,n.jsx)(t.em,{children:"caching"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"accessing-data-in-components",children:"Accessing Data in Components"}),"\n",(0,n.jsxs)(t.p,{children:["While React Router's ",(0,n.jsx)(t.code,{children:"useLoaderData"})," returns whatever you returned from your loader, you can use your data abstraction's hooks instead to get access to the full feature set of that package."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-diff",children:"export default function SomeRouteComponent() {\n- const data = useLoaderData();\n+ const { data } = useQuery(someQueryKey);\n}\n"})}),"\n",(0,n.jsx)(t.h2,{id:"invalidating-data-in-mutations",children:"Invalidating Data in Mutations"}),"\n",(0,n.jsx)(t.p,{children:"Because most of these library's have some mechanism for caching, you'll need to invalidate those caches at some point."}),"\n",(0,n.jsxs)(t.p,{children:["The perfect place to invalidate those caches is in a React Router ",(0,n.jsx)(t.a,{href:"../route/action",children:"action"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-jsx",metastring:"lines=[7]",children:'import { queryClient } from "./query-client";\n\nexport const action = async ({ request, params }) => {\n  const formData = await request.formData();\n  const updates = Object.fromEntries(formData);\n  await updateContact(params.contactId, updates);\n  await queryClient.invalidateQueries(["contacts"]);\n  return redirect(`/contacts/${params.contactId}`);\n};\n'})}),"\n",(0,n.jsxs)(t.h2,{id:"usage-with-defer",children:["Usage with ",(0,n.jsx)(t.code,{children:"defer"})]}),"\n",(0,n.jsx)(t.p,{children:"You can similarly take advantage of the deferred APIs:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-jsx",metastring:"lines=[2,10,14,28]",children:'function loader() {\n  return defer({\n    // no await!\n    someData: queryClient.fetchQuery("someKey", fn),\n  });\n}\n\nfunction Comp() {\n  // *do* useLoaderData for promise\n  const { someData } = useLoaderData();\n  return (\n    <div>\n      <h1>Something</h1>\n      <Await\n        resolve={someData}\n        errorElement={<div>Oops!</div>}\n      >\n        <SomeView />\n      </Await>\n    </div>\n  );\n}\n\nfunction SomeView() {\n  // instead of accessing with useAsyncValue\n  // const someData = useAsyncValue();\n  // `useQuery` as usual\n  const { data } = useQuery("someKey");\n  // ...\n}\n'})}),"\n",(0,n.jsx)(t.h2,{id:"the-overlap",children:"The Overlap"}),"\n",(0,n.jsxs)(t.p,{children:["Hooks like ",(0,n.jsx)(t.code,{children:"useQuery"})," often return pending and error states you can use to branch your UI. With React Router, you can keep all of that branching out of your happy path components and rely on ",(0,n.jsx)(t.a,{href:"../route/error-element",children:(0,n.jsx)(t.code,{children:"errorElement"})}),", ",(0,n.jsx)(t.a,{href:"../hooks/use-navigation",children:(0,n.jsx)(t.code,{children:"useNavigation"})}),", and ",(0,n.jsx)(t.a,{href:"../components/await",children:(0,n.jsx)(t.code,{children:"Await"})})," instead."]}),"\n",(0,n.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,n.jsxs)(t.p,{children:["With all of these APIs working together, you can now use ",(0,n.jsx)(t.a,{href:"../hooks/use-navigation",children:(0,n.jsx)(t.code,{children:"useNavigation"})})," from React Router to build pending states, optimistic UI, and more. Use React Router for timing of data loading, mutations, and navigation state, then use libraries like React Query for the actual implementation of loading, invalidating, storage, and caching."]})]})}function u(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},1151:(e,t,a)=>{a.d(t,{Z:()=>s,a:()=>i});var n=a(7294);const r={},o=n.createContext(r);function i(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);