"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7254],{3040:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var n=r(5893),o=r(1151);const s={title:"Server-Side Rendering",toc:!1,order:6,sidebar_position:6},a="Server Side Rendering",i={id:"guides/ssr",title:"Server-Side Rendering",description:"The most basic server rendering in React Router is pretty straightforward. However, there's a lot more to consider than just getting the right routes to render. Here's an incomplete list of things you'll need to handle:",source:"@site/react-router/docs/guides/ssr.md",sourceDirName:"guides",slug:"/guides/ssr",permalink:"/react-router-v6-searchable-docs/guides/ssr",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1701730876,formattedLastUpdatedAt:"Dec 4, 2023",sidebarPosition:6,frontMatter:{title:"Server-Side Rendering",toc:!1,order:6,sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Guides",permalink:"/react-router-v6-searchable-docs/guides/index"},next:{title:"Contributing",permalink:"/react-router-v6-searchable-docs/guides/contributing"}},d={},c=[{value:"With a Data Router",id:"with-a-data-router",level:2},{value:"Additional Concepts",id:"additional-concepts",level:3},{value:"Hydration",id:"hydration",level:4},{value:"Redirects",id:"redirects",level:4},{value:"Lazy Routes",id:"lazy-routes",level:4},{value:"Without a Data Router",id:"without-a-data-router",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"server-side-rendering",children:"Server Side Rendering"}),"\n",(0,n.jsx)(t.p,{children:"The most basic server rendering in React Router is pretty straightforward. However, there's a lot more to consider than just getting the right routes to render. Here's an incomplete list of things you'll need to handle:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Bundling your code for the server and the browser"}),"\n",(0,n.jsx)(t.li,{children:"Not bundling server-only code into the browser bundles"}),"\n",(0,n.jsx)(t.li,{children:"Code splitting that works on the server and in the browser"}),"\n",(0,n.jsx)(t.li,{children:"Server Side data loading so you actually have something to render"}),"\n",(0,n.jsx)(t.li,{children:"Data loading strategies that work on the client and server"}),"\n",(0,n.jsx)(t.li,{children:"Handling code splitting in the server and client"}),"\n",(0,n.jsx)(t.li,{children:"Proper HTTP status codes and redirects"}),"\n",(0,n.jsx)(t.li,{children:"Environment variables and secrets"}),"\n",(0,n.jsx)(t.li,{children:"Deployment"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Setting all of this up well can be pretty involved but is worth the performance and UX characteristics you can only get when server rendering."}),"\n",(0,n.jsxs)(t.p,{children:["If you want to server render your React Router app, we highly recommend you use ",(0,n.jsx)(t.a,{href:"https://remix.run",children:"Remix"}),". This is another project of ours that's built on top of React Router and handles all of the things mentioned above and more. Give it a shot!"]}),"\n",(0,n.jsxs)(t.p,{children:["If you want to tackle it on your own, you'll need to use ",(0,n.jsx)(t.code,{children:"<StaticRouterProvider>"})," or ",(0,n.jsx)(t.code,{children:"<StaticRouter>"})," on the server, depending on your choice of ",(0,n.jsx)(t.a,{href:"../routers/picking-a-router",children:"router"}),". If using ",(0,n.jsx)(t.code,{children:"<StaticRouter>"}),", please jump down to the ",(0,n.jsx)(t.a,{href:"#without-a-data-router",children:"Without a Data Router"})," section."]}),"\n",(0,n.jsx)(t.h2,{id:"with-a-data-router",children:"With a Data Router"}),"\n",(0,n.jsx)(t.p,{children:"First, you'll need to define your routes for the data router, these routes will be used both on the server and in the client:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"filename=routes.jsx",children:'const React = require("react");\nconst { json, useLoaderData } = require("react-router-dom");\n\nconst routes = [\n  {\n    path: "/",\n    loader() {\n      return json({ message: "Welcome to React Router!" });\n    },\n    Component() {\n      let data = useLoaderData();\n      return <h1>{data.message}</h1>;\n    },\n  },\n];\n\nmodule.exports = routes;\n'})}),"\n",(0,n.jsxs)("docs-info",{children:["We are using CJS modules in these examples for simplicity on the server but generally you'll use ESM modules and leverage a bundler such as ",(0,n.jsx)(t.code,{children:"esbuild"}),", ",(0,n.jsx)(t.code,{children:"vite"}),", or ",(0,n.jsx)(t.code,{children:"webpack"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["With our routes defined, we can create a handler in our express server and load data for the routes using ",(0,n.jsx)(t.code,{children:"createStaticHandler()"}),". Remember that the primary goal of a data router is decoupling the data fetching from rendering, so you'll see that when server-rendering with a data router we have distinct steps for fetching and rendering."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"filename=server.jsx lines=[2-4,11,14-15]",children:'const express = require("express");\nconst {\n  createStaticHandler,\n} = require("react-router-dom/server");\n\nconst createFetchRequest = require("./request");\nconst routes = require("./routes");\n\nconst app = express();\n\nlet handler = createStaticHandler(routes);\n\napp.get("*", async (req, res) => {\n  let fetchRequest = createFetchRequest(req);\n  let context = await handler.query(fetchRequest);\n\n  // We\'ll tackle rendering next...\n});\n\nconst listener = app.listen(3000, () => {\n  let { port } = listener.address();\n  console.log(`Listening on port ${port}`);\n});\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Note we have to first convert the incoming Express request into a Fetch request, which is what the static handler methods operate on. The ",(0,n.jsx)(t.code,{children:"createFetchRequest"})," method is specific to an Express request and in this example is extracted from the ",(0,n.jsx)(t.code,{children:"@remix-run/express"})," adapter:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"filename=request.js",children:'module.exports = function createFetchRequest(req) {\n  let origin = `${req.protocol}://${req.get("host")}`;\n  // Note: This had to take originalUrl into account for presumably vite\'s proxying\n  let url = new URL(req.originalUrl || req.url, origin);\n\n  let controller = new AbortController();\n  req.on("close", () => controller.abort());\n\n  let headers = new Headers();\n\n  for (let [key, values] of Object.entries(req.headers)) {\n    if (values) {\n      if (Array.isArray(values)) {\n        for (let value of values) {\n          headers.append(key, value);\n        }\n      } else {\n        headers.set(key, values);\n      }\n    }\n  }\n\n  let init = {\n    method: req.method,\n    headers,\n    signal: controller.signal,\n  };\n\n  if (req.method !== "GET" && req.method !== "HEAD") {\n    init.body = req.body;\n  }\n\n  return new Request(url.href, init);\n};\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Once we've loaded our data by executing all of the matched route loaders for the incoming request, we use ",(0,n.jsx)(t.code,{children:"createStaticRouter()"})," and ",(0,n.jsx)(t.code,{children:"<StaticRouterProvider>"})," to render the HTML and send a response back to the browser:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"filename=server.jsx lines=[5-16]",children:'app.get("*", async (req, res) => {\n  let fetchRequest = createFetchRequest(req);\n  let context = await handler.query(fetchRequest);\n\n  let router = createStaticRouter(\n    handler.dataRoutes,\n    context\n  );\n  let html = ReactDOMServer.renderToString(\n    <StaticRouterProvider\n      router={router}\n      context={context}\n    />\n  );\n\n  res.send("<!DOCTYPE html>" + html);\n});\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Once we've sent the HTML back to the browser, we'll need to \"hydrate\" the application on the client using ",(0,n.jsx)(t.code,{children:"createBrowserRouter()"})," and ",(0,n.jsx)(t.code,{children:"<RouterProvider>"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-jsx",metastring:"filename=entry-client.jsx lines=[10-15]",children:'import * as React from "react";\nimport * as ReactDOM from "react-dom/client";\nimport {\n  createBrowserRouter,\n  RouterProvider,\n} from "react-router-dom";\n\nimport { routes } from "./routes";\n\nlet router = createBrowserRouter(routes);\n\nReactDOM.hydrateRoot(\n  document.getElementById("app"),\n  <RouterProvider router={router} />\n);\n'})}),"\n",(0,n.jsxs)(t.p,{children:["And with that you've got a server-side-rendered and hydrated application! For a working example, you may also refer to the ",(0,n.jsx)(t.a,{href:"https://github.com/remix-run/react-router/tree/main/examples/ssr-data-router",children:"example"})," in the Github repository."]}),"\n",(0,n.jsx)(t.h3,{id:"additional-concepts",children:"Additional Concepts"}),"\n",(0,n.jsxs)(t.p,{children:["As mentioned above, server-side rendering is tricky at scale and for production-grade applications, and we strongly recommend checking out ",(0,n.jsx)(t.a,{href:"https://remix.run",children:"Remix"})," if that's your goal. But if you are going the manual route, here's a few additional concepts you may need to consider:"]}),"\n",(0,n.jsx)(t.h4,{id:"hydration",children:"Hydration"}),"\n",(0,n.jsxs)(t.p,{children:["A core concept of Server Side Rendering is ",(0,n.jsx)(t.a,{href:"https://react.dev/reference/react-dom/client/hydrateRoot",children:"hydration"}),' which involves "attaching" a client-side React application to server-rendered HTML. To do this correctly, we need to create our client-side React Router application in the same state that it was in during the server render. When your server render loaded data via ',(0,n.jsx)(t.code,{children:"loader"})," functions, we need to send this data up so that we can create our client router with the same loader data for the initial render/hydration."]}),"\n",(0,n.jsxs)(t.p,{children:["The basic usages of ",(0,n.jsx)(t.code,{children:"<StaticRouterProvider>"})," and ",(0,n.jsx)(t.code,{children:"createBrowserRouter"})," shown in this guide handle this for you internally, but if you need to take control over the hydration process you can disable the automatic hydration process via ",(0,n.jsx)(t.a,{href:"../routers/static-router-provider#hydrate",children:(0,n.jsx)(t.code,{children:"<StaticRouterProvider hydrate={false} />"})}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["In some advanced use cases, you may want to partially hydrate a client-side React Router application. You can do this via the ",(0,n.jsx)(t.a,{href:"../routers/create-browser-router#partial-hydration-data",children:(0,n.jsx)(t.code,{children:"future.v7_partialHydration"})})," flag passed to ",(0,n.jsx)(t.code,{children:"createBrowserRouter"}),"."]}),"\n",(0,n.jsx)(t.h4,{id:"redirects",children:"Redirects"}),"\n",(0,n.jsxs)(t.p,{children:["If any loaders redirect, ",(0,n.jsx)(t.code,{children:"handler.query"})," will return the ",(0,n.jsx)(t.code,{children:"Response"})," directly so you should check that and send a redirect response instead of attempting to render an HTML document:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"filename=server.jsx lines=[5-10]",children:'app.get("*", async (req, res) => {\n  let fetchRequest = createFetchRequest(req);\n  let context = await handler.query(fetchRequest);\n\n  if (\n    context instanceof Response &&\n    [301, 302, 303, 307, 308].includes(context.status)\n  ) {\n    return res.redirect(\n      context.status,\n      context.headers.get("Location")\n    );\n  }\n\n  // Render HTML...\n});\n'})}),"\n",(0,n.jsx)(t.h4,{id:"lazy-routes",children:"Lazy Routes"}),"\n",(0,n.jsxs)(t.p,{children:["If you're using ",(0,n.jsx)(t.a,{href:"../route/lazy",children:(0,n.jsx)(t.code,{children:"route.lazy"})})," in your routes, then on the client it's possible you have all the data you need to hydrate, but you don't yet have the route definitions! Ideally, your setup would determine the matched routes on the server and deliver their route bundles on the critical path such that you don't use ",(0,n.jsx)(t.code,{children:"lazy"})," on your initially matched routes. However, if this is not the case you'll need to load these routes and update them in place ",(0,n.jsx)(t.em,{children:"prior"})," to hydrating to avoid the router falling back to a loading state:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-jsx",metastring:"filename=entry-client.jsx",children:'// Determine if any of the initial routes are lazy\nlet lazyMatches = matchRoutes(\n  routes,\n  window.location\n)?.filter((m) => m.route.lazy);\n\n// Load the lazy matches and update the routes before creating your router\n// so we can hydrate the SSR-rendered content synchronously\nif (lazyMatches && lazyMatches?.length > 0) {\n  await Promise.all(\n    lazyMatches.map(async (m) => {\n      let routeModule = await m.route.lazy();\n      Object.assign(m.route, {\n        ...routeModule,\n        lazy: undefined,\n      });\n    })\n  );\n}\n\nlet router = createBrowserRouter(routes);\n\nReactDOM.hydrateRoot(\n  document.getElementById("app"),\n  <RouterProvider router={router} fallbackElement={null} />\n);\n'})}),"\n",(0,n.jsx)(t.p,{children:"See also:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"../routers/create-static-handler",children:(0,n.jsx)(t.code,{children:"createStaticHandler"})})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"../routers/create-static-router",children:(0,n.jsx)(t.code,{children:"createStaticRouter"})})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"../routers/static-router-provider",children:(0,n.jsx)(t.code,{children:"<StaticRouterProvider>"})})}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"without-a-data-router",children:"Without a Data Router"}),"\n",(0,n.jsx)(t.p,{children:'First you\'ll need some sort of "app" or "root" component that gets rendered on the server and in the browser:'}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"filename=App.js",children:'export default function App() {\n  return (\n    <html>\n      <head>\n        <title>Server Rendered App</title>\n      </head>\n      <body>\n        <Routes>\n          <Route path="/" element={<div>Home</div>} />\n          <Route path="/about" element={<div>About</div>} />\n        </Routes>\n        <script src="/build/client.entry.js" />\n      </body>\n    </html>\n  );\n}\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Here's a simple express server that renders the app on the server. Note the use of ",(0,n.jsx)(t.code,{children:"StaticRouter"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"filename=server.entry.js",children:'import express from "express";\nimport ReactDOMServer from "react-dom/server";\nimport { StaticRouter } from "react-router-dom/server";\nimport App from "./App";\n\nlet app = express();\n\napp.get("*", (req, res) => {\n  let html = ReactDOMServer.renderToString(\n    <StaticRouter location={req.url}>\n      <App />\n    </StaticRouter>\n  );\n  res.send("<!DOCTYPE html>" + html);\n});\n\napp.listen(3000);\n'})}),"\n",(0,n.jsxs)(t.p,{children:['And finally, you\'ll need a similar file to "hydrate" the app with your JavaScript bundle that includes the very same ',(0,n.jsx)(t.code,{children:"App"})," component. Note the use of ",(0,n.jsx)(t.code,{children:"BrowserRouter"})," instead of ",(0,n.jsx)(t.code,{children:"StaticRouter"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:"filename=client.entry.js",children:'import * as ReactDOM from "react-dom";\nimport { BrowserRouter } from "react-router-dom";\nimport App from "./App";\n\nReactDOM.hydrate(\n  <BrowserRouter>\n    <App />\n  </BrowserRouter>,\n  document.documentElement\n);\n'})}),"\n",(0,n.jsx)(t.p,{children:"The only real differences from the client entry are:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"StaticRouter"})," instead of ",(0,n.jsx)(t.code,{children:"BrowserRouter"})]}),"\n",(0,n.jsxs)(t.li,{children:["passing the URL from the server to ",(0,n.jsx)(t.code,{children:"<StaticRouter url>"})]}),"\n",(0,n.jsxs)(t.li,{children:["Using ",(0,n.jsx)(t.code,{children:"ReactDOMServer.renderToString"})," instead of ",(0,n.jsx)(t.code,{children:"ReactDOM.render"}),"."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Some parts you'll need to do yourself for this to work:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"How to bundle the code to work in the browser and server"}),"\n",(0,n.jsxs)(t.li,{children:["How to know where the client entry is for ",(0,n.jsx)(t.code,{children:"<script>"})," in the ",(0,n.jsx)(t.code,{children:"<App>"})," component."]}),"\n",(0,n.jsxs)(t.li,{children:["Figuring out data loading (especially for the ",(0,n.jsx)(t.code,{children:"<title>"}),")."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Again, we recommend you give ",(0,n.jsx)(t.a,{href:"https://remix.run",children:"Remix"})," a look. It's the best way to server render a React Router app--and perhaps the best way to build any React app \ud83d\ude09."]})]})}function h(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},1151:(e,t,r)=>{r.d(t,{Z:()=>i,a:()=>a});var n=r(7294);const o={},s=n.createContext(o);function a(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);