"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1178],{4049:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>n,metadata:()=>s,toc:()=>d});var r=t(5893),o=t(1151);const n={title:"useRevalidator",new:!0,sidebar_position:void 0},i="useRevalidator",s={id:"hooks/use-revalidator",title:"useRevalidator",description:"This hook allows you to revalidate the data for any reason. React Router automatically revalidates the data after actions are called, but you may want to revalidate for other reasons like when focus returns to the window.",source:"@site/react-router/docs/hooks/use-revalidator.md",sourceDirName:"hooks",slug:"/hooks/use-revalidator",permalink:"/react-router-v6-searchable-docs/hooks/use-revalidator",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1663868645,formattedLastUpdatedAt:"Sep 22, 2022",frontMatter:{title:"useRevalidator",new:!0},sidebar:"tutorialSidebar",previous:{title:"useResolvedPath",permalink:"/react-router-v6-searchable-docs/hooks/use-resolved-path"},next:{title:"useRouteError",permalink:"/react-router-v6-searchable-docs/hooks/use-route-error"}},l={},d=[{value:"<code>revalidator.state</code>",id:"revalidatorstate",level:2},{value:"<code>revalidator.revalidate()</code>",id:"revalidatorrevalidate",level:2},{value:"Notes",id:"notes",level:2}];function c(e){const a={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.h1,{id:"userevalidator",children:(0,r.jsx)(a.code,{children:"useRevalidator"})}),"\n",(0,r.jsx)(a.p,{children:"This hook allows you to revalidate the data for any reason. React Router automatically revalidates the data after actions are called, but you may want to revalidate for other reasons like when focus returns to the window."}),"\n",(0,r.jsxs)("docs-warning",{children:["This feature only works if using a data router, see ",(0,r.jsx)(a.a,{href:"../routers/picking-a-router",children:"Picking a Router"})]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-tsx",children:'import { useRevalidator } from "react-router-dom";\n\nfunction WindowFocusRevalidator() {\n  let revalidator = useRevalidator();\n\n  useFakeWindowFocus(() => {\n    revalidator.revalidate();\n  });\n\n  return (\n    <div hidden={revalidator.state === "idle"}>\n      Revalidating...\n    </div>\n  );\n}\n'})}),"\n",(0,r.jsxs)(a.p,{children:["Again, React Router already revalidates the data on the page automatically in the vast majority of cases so this should rarely be needed. If you find yourself using this for normal CRUD operations on your data in response to user interactions, you're probably not taking advantage of the other APIs like ",(0,r.jsx)(a.a,{href:"../components/form",children:(0,r.jsx)(a.code,{children:"<Form>"})}),", ",(0,r.jsx)(a.a,{href:"./use-submit",children:(0,r.jsx)(a.code,{children:"useSubmit"})}),", or ",(0,r.jsx)(a.a,{href:"./use-fetcher",children:(0,r.jsx)(a.code,{children:"useFetcher"})})," that do this automatically."]}),"\n",(0,r.jsx)(a.h2,{id:"revalidatorstate",children:(0,r.jsx)(a.code,{children:"revalidator.state"})}),"\n",(0,r.jsxs)(a.p,{children:["Tells you the state the revalidation is in, either ",(0,r.jsx)(a.code,{children:'"idle"'})," or ",(0,r.jsx)(a.code,{children:'"loading"'}),"."]}),"\n",(0,r.jsx)(a.p,{children:"This is useful for creating loading indicators and spinners to let the user know the app is thinking."}),"\n",(0,r.jsx)(a.h2,{id:"revalidatorrevalidate",children:(0,r.jsx)(a.code,{children:"revalidator.revalidate()"})}),"\n",(0,r.jsx)(a.p,{children:"This initiates a revalidation."}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-tsx",children:'function useLivePageData() {\n  let revalidator = useRevalidator();\n  let interval = useInterval(5000);\n\n  useEffect(() => {\n    if (revalidator.state === "idle") {\n      revalidator.revalidate();\n    }\n  }, [interval]);\n}\n'})}),"\n",(0,r.jsx)(a.h2,{id:"notes",children:"Notes"}),"\n",(0,r.jsxs)(a.p,{children:["While you can render multiple occurrences of ",(0,r.jsx)(a.code,{children:"useRevalidator"})," at the same time, underneath it is a singleton. This means when one ",(0,r.jsx)(a.code,{children:"revalidator.revalidate()"})," is called, all instances go into the ",(0,r.jsx)(a.code,{children:'"loading"'})," state together (or rather, they all update to report the singleton state)."]}),"\n",(0,r.jsxs)(a.p,{children:["Race conditions are automatically handled when calling ",(0,r.jsx)(a.code,{children:"revalidate()"})," when a revalidation is already in progress."]}),"\n",(0,r.jsx)(a.p,{children:"If a navigation happens while a revalidation is in flight, the revalidation will be cancelled and fresh data will be requested from all loaders for the next page."})]})}function h(e={}){const{wrapper:a}={...(0,o.a)(),...e.components};return a?(0,r.jsx)(a,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},1151:(e,a,t)=>{t.d(a,{Z:()=>s,a:()=>i});var r=t(7294);const o={},n=r.createContext(o);function i(e){const a=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function s(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(n.Provider,{value:a},e.children)}}}]);