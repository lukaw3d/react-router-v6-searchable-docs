"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9862],{3075:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=t(5893),r=t(1151);const o={title:"Route",new:!0,order:1,sidebar_position:1},s="Route",l={id:"route/route",title:"Route",description:"Routes are perhaps the most important part of a React Router app. They couple URL segments to components, data loading and data mutations. Through route nesting, complex application layouts and data dependencies become simple and declarative.",source:"@site/react-router/docs/route/route.md",sourceDirName:"route",slug:"/route/",permalink:"/react-router-v6-searchable-docs/route/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1701730876,formattedLastUpdatedAt:"Dec 4, 2023",sidebarPosition:1,frontMatter:{title:"Route",new:!0,order:1,sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Route",permalink:"/react-router-v6-searchable-docs/route/index"},next:{title:"action",permalink:"/react-router-v6-searchable-docs/route/action"}},i={},c=[{value:"Type declaration",id:"type-declaration",level:2},{value:"<code>path</code>",id:"path",level:2},{value:"Dynamic Segments",id:"dynamic-segments",level:3},{value:"Optional Segments",id:"optional-segments",level:3},{value:"Splats",id:"splats",level:3},{value:"Layout Routes",id:"layout-routes",level:3},{value:"<code>index</code>",id:"index",level:2},{value:"<code>children</code>",id:"children",level:2},{value:"<code>caseSensitive</code>",id:"casesensitive",level:2},{value:"<code>loader</code>",id:"loader",level:2},{value:"<code>action</code>",id:"action",level:2},{value:"<code>element</code>/<code>Component</code>",id:"elementcomponent",level:2},{value:"<code>errorElement</code>/<code>ErrorBoundary</code>",id:"errorelementerrorboundary",level:2},{value:"<code>hydrateFallbackElement</code>/<code>HydrateFallback</code>",id:"hydratefallbackelementhydratefallback",level:2},{value:"<code>handle</code>",id:"handle",level:2},{value:"<code>lazy</code>",id:"lazy",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"route",children:(0,a.jsx)(n.code,{children:"Route"})}),"\n",(0,a.jsx)(n.p,{children:"Routes are perhaps the most important part of a React Router app. They couple URL segments to components, data loading and data mutations. Through route nesting, complex application layouts and data dependencies become simple and declarative."}),"\n",(0,a.jsx)(n.p,{children:"Routes are objects passed to the router creation functions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'const router = createBrowserRouter([\n  {\n    // it renders this element\n    element: <Team />,\n\n    // when the URL matches this segment\n    path: "teams/:teamId",\n\n    // with this data loaded before rendering\n    loader: async ({ request, params }) => {\n      return fetch(\n        `/fake/api/teams/${params.teamId}.json`,\n        { signal: request.signal }\n      );\n    },\n\n    // performing this mutation when data is submitted to it\n    action: async ({ request }) => {\n      return updateFakeTeam(await request.formData());\n    },\n\n    // and renders this element in case something went wrong\n    errorElement: <ErrorBoundary />,\n  },\n]);\n'})}),"\n",(0,a.jsxs)(n.p,{children:["You can also declare your routes with JSX and ",(0,a.jsx)(n.a,{href:"../utils/create-routes-from-elements",children:(0,a.jsx)(n.code,{children:"createRoutesFromElements"})}),", the props to the element are identical to the properties of the route objects:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'const router = createBrowserRouter(\n  createRoutesFromElements(\n    <Route\n      element={<Team />}\n      path="teams/:teamId"\n      loader={async ({ params }) => {\n        return fetch(\n          `/fake/api/teams/${params.teamId}.json`\n        );\n      }}\n      action={async ({ request }) => {\n        return updateFakeTeam(await request.formData());\n      }}\n      errorElement={<ErrorBoundary />}\n    />\n  )\n);\n'})}),"\n",(0,a.jsx)(n.p,{children:"Neither style is discouraged and behavior is identical. For the majority of this doc we will use the JSX style because that's what most people are accustomed to in the context of React Router."}),"\n",(0,a.jsxs)("docs-info",{children:["When using ",(0,a.jsx)(n.code,{children:"RouterProvider"}),", if you do not wish to specify a React element (i.e., ",(0,a.jsx)(n.code,{children:"element={<MyComponent />}"}),") you may specify a ",(0,a.jsx)(n.code,{children:"Component"})," instead (i.e., ",(0,a.jsx)(n.code,{children:"Component={MyComponent}"}),") and React Router will call ",(0,a.jsx)(n.code,{children:"createElement"})," for you internally. You should only do this for ",(0,a.jsx)(n.code,{children:"RouterProvider"})," applications though since using ",(0,a.jsx)(n.code,{children:"Component"})," inside of ",(0,a.jsx)(n.code,{children:"<Routes>"})," will de-optimize React's ability to reuse the created element across renders."]}),"\n",(0,a.jsx)(n.h2,{id:"type-declaration",children:"Type declaration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'interface RouteObject {\n  path?: string;\n  index?: boolean;\n  children?: React.ReactNode;\n  caseSensitive?: boolean;\n  id?: string;\n  loader?: LoaderFunction;\n  action?: ActionFunction;\n  element?: React.ReactNode | null;\n  hydrateFallbackElement?: React.ReactNode | null;\n  errorElement?: React.ReactNode | null;\n  Component?: React.ComponentType | null;\n  HydrateFallback?: React.ComponentType | null;\n  ErrorBoundary?: React.ComponentType | null;\n  handle?: RouteObject["handle"];\n  shouldRevalidate?: ShouldRevalidateFunction;\n  lazy?: LazyRouteFunction<RouteObject>;\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"path",children:(0,a.jsx)(n.code,{children:"path"})}),"\n",(0,a.jsx)(n.p,{children:"The path pattern to match against the URL to determine if this route matches a URL, link href, or form action."}),"\n",(0,a.jsx)(n.h3,{id:"dynamic-segments",children:"Dynamic Segments"}),"\n",(0,a.jsxs)(n.p,{children:["If a path segment starts with ",(0,a.jsx)(n.code,{children:":"}),' then it becomes a "dynamic segment". When the route matches the URL, the dynamic segment will be parsed from the URL and provided as ',(0,a.jsx)(n.code,{children:"params"})," to other router APIs."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'<Route\n  // this path will match URLs like\n  // - /teams/hotspur\n  // - /teams/real\n  path="/teams/:teamId"\n  // the matching param will be available to the loader\n  loader={({ params }) => {\n    console.log(params.teamId); // "hotspur"\n  }}\n  // and the action\n  action={({ params }) => {}}\n  element={<Team />}\n/>;\n\n// and the element through `useParams`\nfunction Team() {\n  let params = useParams();\n  console.log(params.teamId); // "hotspur"\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"You can have multiple dynamic segments in one route path:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'<Route path="/c/:categoryId/p/:productId" />;\n// both will be available\nparams.categoryId;\nparams.productId;\n'})}),"\n",(0,a.jsx)(n.p,{children:'Dynamic segments cannot be "partial":'}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\ud83d\udeab ",(0,a.jsx)(n.code,{children:'"/teams-:teamId"'})]}),"\n",(0,a.jsxs)(n.li,{children:["\u2705 ",(0,a.jsx)(n.code,{children:'"/teams/:teamId"'})]}),"\n",(0,a.jsxs)(n.li,{children:["\ud83d\udeab ",(0,a.jsx)(n.code,{children:'"/:category--:productId"'})]}),"\n",(0,a.jsxs)(n.li,{children:["\u2705 ",(0,a.jsx)(n.code,{children:'"/:productSlug"'})]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"You can still support URL patterns like that, you just have to do a bit of your own parsing:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'function Product() {\n  const { productSlug } = useParams();\n  const [category, product] = productSlug.split("--");\n  // ...\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"optional-segments",children:"Optional Segments"}),"\n",(0,a.jsxs)(n.p,{children:["You can make a route segment optional by adding a ",(0,a.jsx)(n.code,{children:"?"})," to the end of the segment."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'<Route\n  // this path will match URLs like\n  // - /categories\n  // - /en/categories\n  // - /fr/categories\n  path="/:lang?/categories"\n  // the matching param might be available to the loader\n  loader={({ params }) => {\n    console.log(params["lang"]); // "en"\n  }}\n  // and the action\n  action={({ params }) => {}}\n  element={<Categories />}\n/>;\n\n// and the element through `useParams`\nfunction Categories() {\n  let params = useParams();\n  console.log(params.lang);\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"You can have optional static segments, too:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'<Route path="/project/task?/:taskId" />\n'})}),"\n",(0,a.jsx)(n.h3,{id:"splats",children:"Splats"}),"\n",(0,a.jsxs)(n.p,{children:['Also known as "catchall" and "star" segments. If a route path pattern ends with ',(0,a.jsx)(n.code,{children:"/*"})," then it will match any characters following the ",(0,a.jsx)(n.code,{children:"/"}),", including other ",(0,a.jsx)(n.code,{children:"/"})," characters."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'<Route\n  // this path will match URLs like\n  // - /files\n  // - /files/one\n  // - /files/one/two\n  // - /files/one/two/three\n  path="/files/*"\n  // the matching param will be available to the loader\n  loader={({ params }) => {\n    console.log(params["*"]); // "one/two"\n  }}\n  // and the action\n  action={({ params }) => {}}\n  element={<Team />}\n/>;\n\n// and the element through `useParams`\nfunction Team() {\n  let params = useParams();\n  console.log(params["*"]); // "one/two"\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["You can destructure the ",(0,a.jsx)(n.code,{children:"*"}),", you just have to assign it a new name. A common name is ",(0,a.jsx)(n.code,{children:"splat"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'let { org, "*": splat } = params;\n'})}),"\n",(0,a.jsx)(n.h3,{id:"layout-routes",children:"Layout Routes"}),"\n",(0,a.jsx)(n.p,{children:'Omitting the path makes this route a "layout route". It participates in UI nesting, but it does not add any segments to the URL.'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'<Route\n  element={\n    <div>\n      <h1>Layout</h1>\n      <Outlet />\n    </div>\n  }\n>\n  <Route path="/" element={<h2>Home</h2>} />\n  <Route path="/about" element={<h2>About</h2>} />\n</Route>\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In this example, ",(0,a.jsx)(n.code,{children:"<h1>Layout</h1>"})," will be rendered along with each child route's ",(0,a.jsx)(n.code,{children:"element"})," prop, via the layout route's ",(0,a.jsx)(n.a,{href:"../components/outlet",children:"Outlet"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"index",children:(0,a.jsx)(n.code,{children:"index"})}),"\n",(0,a.jsxs)(n.p,{children:["Determines if the route is an index route. Index routes render into their parent's ",(0,a.jsx)(n.a,{href:"../components/outlet",children:"Outlet"})," at their parent's URL (like a default child route)."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",metastring:"[2]",children:'<Route path="/teams" element={<Teams />}>\n  <Route index element={<TeamsIndex />} />\n  <Route path=":teamId" element={<Team />} />\n</Route>\n'})}),"\n",(0,a.jsxs)(n.p,{children:["These special routes can be confusing to understand at first, so we have a guide dedicated to them here: ",(0,a.jsx)(n.a,{href:"../start/concepts#index-routes",children:"Index Route"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"children",children:(0,a.jsx)(n.code,{children:"children"})}),"\n",(0,a.jsx)("docs-warning",{children:"(TODO: need to talk about nesting, maybe even a separate doc)"}),"\n",(0,a.jsx)(n.h2,{id:"casesensitive",children:(0,a.jsx)(n.code,{children:"caseSensitive"})}),"\n",(0,a.jsx)(n.p,{children:"Instructs the route to match case or not:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'<Route caseSensitive path="/wEll-aCtuA11y" />\n'})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Will match ",(0,a.jsx)(n.code,{children:'"wEll-aCtuA11y"'})]}),"\n",(0,a.jsxs)(n.li,{children:["Will not match ",(0,a.jsx)(n.code,{children:'"well-actua11y"'})]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"loader",children:(0,a.jsx)(n.code,{children:"loader"})}),"\n",(0,a.jsxs)(n.p,{children:["The route loader is called before the route renders and provides data for the element through ",(0,a.jsx)(n.a,{href:"../hooks/use-loader-data",children:(0,a.jsx)(n.code,{children:"useLoaderData"})}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",metastring:"[3-5]",children:'<Route\n  path="/teams/:teamId"\n  loader={({ params }) => {\n    return fetchTeam(params.teamId);\n  }}\n/>;\n\nfunction Team() {\n  let team = useLoaderData();\n  // ...\n}\n'})}),"\n",(0,a.jsxs)("docs-warning",{children:["If you are not using a data router like ",(0,a.jsx)(n.a,{href:"../routers/create-browser-router",children:(0,a.jsx)(n.code,{children:"createBrowserRouter"})}),", this will do nothing"]}),"\n",(0,a.jsxs)(n.p,{children:["Please see the ",(0,a.jsx)(n.a,{href:"./loader",children:"loader"})," documentation for more details."]}),"\n",(0,a.jsx)(n.h2,{id:"action",children:(0,a.jsx)(n.code,{children:"action"})}),"\n",(0,a.jsxs)(n.p,{children:["The route action is called when a submission is sent to the route from a ",(0,a.jsx)(n.a,{href:"../components/form",children:"Form"}),", ",(0,a.jsx)(n.a,{href:"../hooks/use-fetcher",children:"fetcher"}),", or ",(0,a.jsx)(n.a,{href:"../hooks/use-submit",children:"submission"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",metastring:"[3-5]",children:'<Route\n  path="/teams/:teamId"\n  action={({ request }) => {\n    const formData = await request.formData();\n    return updateTeam(formData);\n  }}\n/>\n'})}),"\n",(0,a.jsxs)("docs-warning",{children:["If you are not using a data router like ",(0,a.jsx)(n.a,{href:"../routers/create-browser-router",children:(0,a.jsx)(n.code,{children:"createBrowserRouter"})}),", this will do nothing"]}),"\n",(0,a.jsxs)(n.p,{children:["Please see the ",(0,a.jsx)(n.a,{href:"./action",children:"action"})," documentation for more details."]}),"\n",(0,a.jsxs)(n.h2,{id:"elementcomponent",children:[(0,a.jsx)(n.code,{children:"element"}),"/",(0,a.jsx)(n.code,{children:"Component"})]}),"\n",(0,a.jsx)(n.p,{children:"The React Element/Component to render when the route matches the URL."}),"\n",(0,a.jsxs)(n.p,{children:["If you want to create the React Element, use ",(0,a.jsx)(n.code,{children:"element"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'<Route path="/for-sale" element={<Properties />} />\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Otherwise use ",(0,a.jsx)(n.code,{children:"Component"})," and React Router will create the React Element for you:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'<Route path="/for-sale" Component={Properties} />\n'})}),"\n",(0,a.jsxs)("docs-warning",{children:["You should only opt into the ",(0,a.jsx)(n.code,{children:"Component"})," API for data routes via ",(0,a.jsx)(n.code,{children:"RouterProvider"}),". Using this API on a ",(0,a.jsx)(n.code,{children:"<Route>"})," inside ",(0,a.jsx)(n.code,{children:"<Routes>"})," will de-optimize React's ability to reuse the created element across renders."]}),"\n",(0,a.jsxs)(n.h2,{id:"errorelementerrorboundary",children:[(0,a.jsx)(n.code,{children:"errorElement"}),"/",(0,a.jsx)(n.code,{children:"ErrorBoundary"})]}),"\n",(0,a.jsxs)(n.p,{children:["When a route throws an exception while rendering, in a ",(0,a.jsx)(n.code,{children:"loader"})," or in an ",(0,a.jsx)(n.code,{children:"action"}),", this React Element/Component will render instead of the normal ",(0,a.jsx)(n.code,{children:"element"}),"/",(0,a.jsx)(n.code,{children:"Component"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["If you want to create the React Element on your own, use ",(0,a.jsx)(n.code,{children:"errorElement"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'<Route\n  path="/for-sale"\n  // if this throws an error while rendering\n  element={<Properties />}\n  // or this while loading properties\n  loader={() => loadProperties()}\n  // or this while creating a property\n  action={async ({ request }) =>\n    createProperty(await request.formData())\n  }\n  // then this element will render\n  errorElement={<ErrorBoundary />}\n/>\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Otherwise use ",(0,a.jsx)(n.code,{children:"ErrorBoundary"})," and React Router will create the React Element for you:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'<Route\n  path="/for-sale"\n  Component={Properties}\n  loader={() => loadProperties()}\n  action={async ({ request }) =>\n    createProperty(await request.formData())\n  }\n  ErrorBoundary={ErrorBoundary}\n/>\n'})}),"\n",(0,a.jsxs)("docs-warning",{children:["If you are not using a data router like ",(0,a.jsx)(n.a,{href:"../routers/create-browser-router",children:(0,a.jsx)(n.code,{children:"createBrowserRouter"})}),", this will do nothing"]}),"\n",(0,a.jsxs)(n.p,{children:["Please see the ",(0,a.jsx)(n.a,{href:"./error-element",children:"errorElement"})," documentation for more details."]}),"\n",(0,a.jsxs)(n.h2,{id:"hydratefallbackelementhydratefallback",children:[(0,a.jsx)(n.code,{children:"hydrateFallbackElement"}),"/",(0,a.jsx)(n.code,{children:"HydrateFallback"})]}),"\n",(0,a.jsxs)(n.p,{children:["If you are using ",(0,a.jsx)(n.a,{href:"../guides/ssr",children:"Server-Side Rendering"})," and you are leveraging ",(0,a.jsx)(n.a,{href:"../routers/create-browser-router#partial-hydration-data",children:"partial hydration"}),", then you can specify an Element/Component to render for non-hydrated routes during the initial hydration of the application."]}),"\n",(0,a.jsxs)("docs-warning",{children:["If you are not using a data router like ",(0,a.jsx)(n.a,{href:"../routers/create-browser-router",children:(0,a.jsx)(n.code,{children:"createBrowserRouter"})}),", this will do nothing"]}),"\n",(0,a.jsxs)("docs-warning",{children:["This is only intended for more advanced uses cases such as Remix's ",(0,a.jsx)(n.a,{href:"https://remix.run/route/client-loader",children:(0,a.jsx)(n.code,{children:"clientLoader"})})," functionality. Most SSR apps will not need to leverage these route properties."]}),"\n",(0,a.jsxs)(n.p,{children:["Please see the ",(0,a.jsx)(n.a,{href:"./hydrate-fallback-element",children:"hydrateFallbackElement"})," documentation for more details."]}),"\n",(0,a.jsx)(n.h2,{id:"handle",children:(0,a.jsx)(n.code,{children:"handle"})}),"\n",(0,a.jsxs)(n.p,{children:["Any application-specific data. Please see the ",(0,a.jsx)(n.a,{href:"../hooks/use-matches",children:"useMatches"})," documentation for details and examples."]}),"\n",(0,a.jsx)(n.h2,{id:"lazy",children:(0,a.jsx)(n.code,{children:"lazy"})}),"\n",(0,a.jsxs)(n.p,{children:["In order to keep your application bundles small and support code-splitting of your routes, each route can provide an async function that resolves the non-route-matching portions of your route definition (",(0,a.jsx)(n.code,{children:"loader"}),", ",(0,a.jsx)(n.code,{children:"action"}),", ",(0,a.jsx)(n.code,{children:"Component"}),"/",(0,a.jsx)(n.code,{children:"element"}),", ",(0,a.jsx)(n.code,{children:"ErrorBoundary"}),"/",(0,a.jsx)(n.code,{children:"errorElement"}),", etc.)."]}),"\n",(0,a.jsxs)(n.p,{children:["Each ",(0,a.jsx)(n.code,{children:"lazy"})," function will typically return the result of a dynamic import."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'let routes = createRoutesFromElements(\n  <Route path="/" element={<Layout />}>\n    <Route path="a" lazy={() => import("./a")} />\n    <Route path="b" lazy={() => import("./b")} />\n  </Route>\n);\n'})}),"\n",(0,a.jsx)(n.p,{children:"Then in your lazy route modules, export the properties you want defined for the route:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"export async function loader({ request }) {\n  let data = await fetchData(request);\n  return json(data);\n}\n\nexport function Component() {\n  let data = useLoaderData();\n\n  return (\n    <>\n      <h1>You made it!</h1>\n      <p>{data}</p>\n    </>\n  );\n}\n"})}),"\n",(0,a.jsxs)("docs-warning",{children:["If you are not using a data router like ",(0,a.jsx)(n.a,{href:"../routers/create-browser-router",children:(0,a.jsx)(n.code,{children:"createBrowserRouter"})}),", this will do nothing"]}),"\n",(0,a.jsxs)(n.p,{children:["Please see the ",(0,a.jsx)(n.a,{href:"./lazy",children:"lazy"})," documentation for more details."]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>l,a:()=>s});var a=t(7294);const r={},o=a.createContext(r);function s(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);