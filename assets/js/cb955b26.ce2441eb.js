"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[622],{3813:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var n=r(5893),a=r(1151);const s={title:"API Development Strategy",new:!0,sidebar_position:void 0},i="API Development Strategy",o={id:"guides/api-development-strategy",title:"API Development Strategy",description:"Let's cut to the chase - major version upgrades can be a pain. Especially for something as foundational to your application as the framework or router it's built on. For Remix and React Router, we want to do our best to give you the smoothest upgrade experience possible.",source:"@site/react-router/docs/guides/api-development-strategy.md",sourceDirName:"guides",slug:"/guides/api-development-strategy",permalink:"/react-router-v6-searchable-docs/guides/api-development-strategy",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1701794153,formattedLastUpdatedAt:"Dec 5, 2023",frontMatter:{title:"API Development Strategy",new:!0},sidebar:"tutorialSidebar",previous:{title:"Contributing",permalink:"/react-router-v6-searchable-docs/guides/contributing"},next:{title:"Code Splitting",permalink:"/react-router-v6-searchable-docs/guides/code-splitting"}},l={},d=[{value:"Goals",id:"goals",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Unstable vs. V7 Flags",id:"unstable-vs-v7-flags",level:2},{value:"Example New Feature Flow",id:"example-new-feature-flow",level:3},{value:"Current Future Flags",id:"current-future-flags",level:2},{value:"<code>@remix-run/router</code> Future Flags",id:"remix-runrouter-future-flags",level:3},{value:"React Router Future Flags",id:"react-router-future-flags",level:3}];function c(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"api-development-strategy",children:"API Development Strategy"}),"\n",(0,n.jsxs)(t.p,{children:["Let's cut to the chase - major version upgrades can be a ",(0,n.jsx)(t.em,{children:"pain"}),". Especially for something as foundational to your application as the framework or router it's built on. For Remix and React Router, we want to do our best to give you the smoothest upgrade experience possible."]}),"\n",(0,n.jsxs)("docs-info",{children:["This strategy is discussed in more detail in our ",(0,n.jsx)(t.a,{href:"https://remix.run/blog/future-flags",children:"Future Flags"})," blog post, so give that a read if you want any more info at the end of this doc!"]}),"\n",(0,n.jsx)(t.h2,{id:"goals",children:"Goals"}),"\n",(0,n.jsx)(t.p,{children:"Our goals for major Remix and React Router releases are:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Developers can opt-into SemVer-major features individually ",(0,n.jsx)(t.em,{children:"as they are released"})," instead of having to wait to adopt them all at once when a new major version hits NPM"]}),"\n",(0,n.jsx)(t.li,{children:"Having opted into features ahead-of-time, developers can upgrade to new major versions in a single short-lived branch/commit (hours, not weeks)"}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"implementation",children:"Implementation"}),"\n",(0,n.jsxs)(t.p,{children:["We plan to do this via what we're calling ",(0,n.jsx)(t.strong,{children:"Future Flags"})," that you'll provide when you initialize your ",(0,n.jsx)(t.a,{href:"../routers/picking-a-router",children:"Data Router"}),". Think of these as ",(0,n.jsx)(t.strong,{children:"feature flags for future features"}),". As we implement new features, we always try to do them in a backwards-compatible way. But when a breaking change is warranted, we don't table that feature up for an ",(0,n.jsx)(t.em,{children:"eventual"})," v7 release. Instead, we add a ",(0,n.jsx)(t.strong,{children:"Future Flag"})," and implement the new feature alongside the current behavior in a v6 minor release. This allows users to start using the feature, providing feedback, and reporting bugs ",(0,n.jsx)(t.em,{children:"immediately"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["That way, not only can you adopt features incrementally (and eagerly without a major version bump), we can also work out any kinks incrementally ",(0,n.jsx)(t.em,{children:"before"})," releasing v7. Eventually we also then add deprecation warnings to the v6 releases to nudge users to the new behavior. Then in v7 we remove the old v6 approach, remove the deprecations, and remove the flag - thus making the flagged behavior the new default in v7. If at the time v6 is released, an application has opted into ",(0,n.jsx)(t.em,{children:"all"})," future flags and updated their code - then they should just be able to update their dependency to v7, delete the future flags, and be running on v7 in a matter of minutes."]}),"\n",(0,n.jsx)(t.h2,{id:"unstable-vs-v7-flags",children:"Unstable vs. V7 Flags"}),"\n",(0,n.jsx)(t.p,{children:"Future flags come in 2 forms:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.code,{children:"future.unstable_feature"})})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"unstable_"})," flags allow us to iterate on the API with early adopters as if we're in ",(0,n.jsx)(t.code,{children:"v0.x.x"})," versions, but for a specific feature. This avoids churning the API for all users and arriving at better APIs in the final release. This ",(0,n.jsx)(t.em,{children:"does not mean"})," that we think the feature is bug-ridden! We ",(0,n.jsx)(t.em,{children:"absolutely"})," want early adopters to start using these features so we can iterate on (and/or gain confidence in) the API."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.code,{children:"future.v7_feature"})})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"v7_"})," indicates a breaking change from v6 behavior and implies (1) that the API is considered stable and will not under any more breaking changes and (2) that the API will become the default behavior in v7. A ",(0,n.jsx)(t.code,{children:"v7_"})," flag ",(0,n.jsx)(t.em,{children:"does not"})," mean the feature is bug-free - no software is! Our recommendation is to upgrade to v7 flags as you have the time, as it will make your v7 upgrade ",(0,n.jsx)(t.em,{children:"much"})," smoother."]}),"\n",(0,n.jsx)(t.h3,{id:"example-new-feature-flow",children:"Example New Feature Flow"}),"\n",(0,n.jsx)(t.p,{children:"The decision flow for a new feature looks something like this (note this diagram is in relation to Remix v1/v2 but applies to React Router v6/v7 as well):"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:"https://remix.run/docs-images/feature-flowchart.png",alt:"Flowchart of the decision process for how to introduce a new feature"})}),"\n",(0,n.jsx)(t.p,{children:"The lifecycle is thus either:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Non-Breaking + Stable API Feature -> Lands in v6"}),"\n",(0,n.jsxs)(t.li,{children:["Non-Breaking + Unstable API -> ",(0,n.jsx)(t.code,{children:"future.unstable_"})," flag -> Lands in v6"]}),"\n",(0,n.jsxs)(t.li,{children:["Breaking + Stable API Feature -> ",(0,n.jsx)(t.code,{children:"future.v7_"})," flag -> Lands in v7"]}),"\n",(0,n.jsxs)(t.li,{children:["Breaking + Unstable API -> ",(0,n.jsx)(t.code,{children:"future.unstable_"})," flag -> ",(0,n.jsx)(t.code,{children:"future.v7_"})," flag -> Lands in v7"]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"current-future-flags",children:"Current Future Flags"}),"\n",(0,n.jsx)(t.p,{children:"Here's the current future flags in React Router v6 today."}),"\n",(0,n.jsxs)(t.h3,{id:"remix-runrouter-future-flags",children:[(0,n.jsx)(t.code,{children:"@remix-run/router"})," Future Flags"]}),"\n",(0,n.jsxs)(t.p,{children:["These flags are only applicable when using a ",(0,n.jsx)(t.a,{href:"../routers/picking-a-router",children:"Data Router"})," and are passed when creating the ",(0,n.jsx)(t.code,{children:"router"})," instance:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"const router = createBrowserRouter(routes, {\n  future: {\n    v7_normalizeFormMethod: true,\n  },\n});\n"})}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Flag"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"v7_fetcherPersist"})}),(0,n.jsxs)(t.td,{children:["Delay active fetcher cleanup until they return to an ",(0,n.jsx)(t.code,{children:"idle"})," state"]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"v7_normalizeFormMethod"})}),(0,n.jsxs)(t.td,{children:["Normalize ",(0,n.jsx)(t.code,{children:"useNavigation().formMethod"})," to be an uppercase HTTP Method"]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.a,{href:"../routers/create-browser-router#partial-hydration-data",children:(0,n.jsx)(t.code,{children:"v7_partialHydration"})})}),(0,n.jsx)(t.td,{children:"Support partial hydration for Server-rendered apps"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"v7_prependBasename"})}),(0,n.jsx)(t.td,{children:"Prepend the router basename to navigate/fetch paths"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.a,{href:"../hooks/use-resolved-path#splat-paths",children:(0,n.jsx)(t.code,{children:"v7_relativeSplatPath"})})}),(0,n.jsx)(t.td,{children:"Fix buggy relative path resolution in splat routes"})]})]})]}),"\n",(0,n.jsx)(t.h3,{id:"react-router-future-flags",children:"React Router Future Flags"}),"\n",(0,n.jsx)(t.p,{children:"These flags apply to both Data and non-Data Routers and are passed to the rendered React component:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-jsx",children:"<BrowserRouter future={{ v7_startTransition: true }}>\n  <Routes>{/*...*/}</Routes>\n</BrowserRouter>\n"})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-jsx",children:"<RouterProvider\n  router={router}\n  future={{ v7_startTransition: true }}\n/>\n"})}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Flag"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsx)(t.tbody,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"v7_startTransition"})}),(0,n.jsxs)(t.td,{children:["Wrap all router state updates in ",(0,n.jsx)(t.a,{href:"https://react.dev/reference/react/startTransition",children:(0,n.jsx)(t.code,{children:"React.startTransition"})})]})]})})]})]})}function h(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},1151:(e,t,r)=>{r.d(t,{Z:()=>o,a:()=>i});var n=r(7294);const a={},s=n.createContext(a);function i(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);