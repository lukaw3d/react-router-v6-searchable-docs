"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6090],{5921:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>u});var o=n(5893),r=n(1151);const s={title:"Migrating to RouterProvider",order:1,sidebar_position:1},i="Migrating to RouterProvider",a={id:"upgrading/v6-data",title:"Migrating to RouterProvider",description:"When we originally began bringing the Remix Data APIs over to React Router we realized that they brought about a pretty different way of structuring your routes. Instead of discovering routes via the `` component as React rendered the component tree, we needed to lift the route definitions so we could decouple fetching from rendering.",source:"@site/react-router/docs/upgrading/v6-data.md",sourceDirName:"upgrading",slug:"/upgrading/v6-data",permalink:"/react-router-v6-searchable-docs/upgrading/v6-data",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1685460614,formattedLastUpdatedAt:"May 30, 2023",sidebarPosition:1,frontMatter:{title:"Migrating to RouterProvider",order:1,sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Upgrading",permalink:"/react-router-v6-searchable-docs/upgrading/index"},next:{title:"Upgrading from v5",permalink:"/react-router-v6-searchable-docs/upgrading/v5"}},d={},u=[{value:"Differences",id:"differences",level:2},{value:"Migrating",id:"migrating",level:2},{value:"Current Application",id:"current-application",level:3},{value:"Add RouterProvider with a root splat route",id:"add-routerprovider-with-a-root-splat-route",level:3},{value:"Start lifting routes and leveraging the data APIs",id:"start-lifting-routes-and-leveraging-the-data-apis",level:3},{value:"FAQ",id:"faq",level:2},{value:"But I&#39;ve got stuff between <code>&lt;BrowserRouter&gt;</code> and <code>&lt;Routes&gt;</code>",id:"but-ive-got-stuff-between-browserrouter-and-routes",level:3}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"migrating-to-routerprovider",children:"Migrating to RouterProvider"}),"\n",(0,o.jsxs)(t.p,{children:["When we originally began bringing the ",(0,o.jsx)(t.a,{href:"https://remix.run/blog/remixing-react-router",children:"Remix Data APIs over to React Router"})," we realized that they brought about a pretty different way of structuring your routes. Instead of discovering routes via the ",(0,o.jsx)(t.a,{href:"../components/routes",children:(0,o.jsx)(t.code,{children:"<Routes>"})})," component ",(0,o.jsx)(t.em,{children:"as React rendered the component tree"}),", we needed to ",(0,o.jsx)(t.em,{children:"lift"})," the route definitions so we could ",(0,o.jsx)(t.a,{href:"https://www.youtube.com/watch?v=95B8mnhzoCM",children:"decouple fetching from rendering"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["This brought about an interesting conundrum. We've got tons of v6 ",(0,o.jsx)(t.a,{href:"../router-components/browser-router",children:(0,o.jsx)(t.code,{children:"BrowserRouter"})})," apps out there happily defining their routes via ",(0,o.jsx)(t.code,{children:"<Routes>"})," components -- how can we provide them with a smooth upgrade experience that doesn't require a big-bang migration to the new approach? This ruled out a new major version and we focused on adding these new features in a ",(0,o.jsx)(t.em,{children:"fully backwards compatible"})," way that would provide users an ",(0,o.jsx)(t.em,{children:"incremental"})," upgrade path from ",(0,o.jsx)(t.a,{href:"../router-components/browser-router",children:(0,o.jsx)(t.code,{children:"BrowserRouter"})})," to ",(0,o.jsx)(t.a,{href:"../routers/router-provider",children:(0,o.jsx)(t.code,{children:"RouterProvider"})}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"differences",children:"Differences"}),"\n",(0,o.jsxs)(t.p,{children:["The first thing to be aware of is the presence of a handful of new ",(0,o.jsx)(t.a,{href:"../routers/picking-a-router#data-apis",children:"Data APIs"})," that only work on routes ",(0,o.jsx)(t.em,{children:"defined"})," via the new ",(0,o.jsx)(t.a,{href:"../routers/picking-a-router",children:"data routers"})," (i.e., ",(0,o.jsx)(t.a,{href:"../routers/create-browser-router",children:(0,o.jsx)(t.code,{children:"createBrowserRouter"})}),"). These include a few categories of APIs:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Route-level data APIs such as ",(0,o.jsx)(t.code,{children:"loader"}),", ",(0,o.jsx)(t.code,{children:"action"}),", ",(0,o.jsx)(t.code,{children:"shouldRevalidate"}),", ",(0,o.jsx)(t.code,{children:"handle"}),", and ",(0,o.jsx)(t.code,{children:"lazy"})]}),"\n",(0,o.jsxs)(t.li,{children:["In-component data hooks such as ",(0,o.jsx)(t.code,{children:"useLoaderData"}),", ",(0,o.jsx)(t.code,{children:"useActionData"}),", ",(0,o.jsx)(t.code,{children:"useFetcher"}),", ",(0,o.jsx)(t.code,{children:"useMatches"}),", ",(0,o.jsx)(t.code,{children:"useNavigation"}),", etc."]}),"\n",(0,o.jsxs)(t.li,{children:["Error-handling APIs such as ",(0,o.jsx)(t.code,{children:"route.errorElement"}),", ",(0,o.jsx)(t.code,{children:"route.ErrorBoundary"}),", and ",(0,o.jsx)(t.code,{children:"useRouteError"})]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["The rest of the APIs that existed prior to v6.4.0 are still usable in ",(0,o.jsx)(t.em,{children:"both"})," ",(0,o.jsx)(t.code,{children:"BrowserRouter"})," and ",(0,o.jsx)(t.code,{children:"RouterProvider"})," apps. These include common hooks/components such as ",(0,o.jsx)(t.code,{children:"useNavigate"}),", ",(0,o.jsx)(t.code,{children:"useLocation"}),", ",(0,o.jsx)(t.code,{children:"useParams"}),", ",(0,o.jsx)(t.code,{children:"<Link>"}),", ",(0,o.jsx)(t.code,{children:"<Outlet />"}),", etc."]}),"\n",(0,o.jsx)(t.h2,{id:"migrating",children:"Migrating"}),"\n",(0,o.jsxs)(t.p,{children:["We built the new ",(0,o.jsx)(t.code,{children:"<RouterProvider>"})," component such that it would enable the new Data APIs on routes defined at the root router, while not excluding descendant ",(0,o.jsx)(t.code,{children:"<Routes>"})," trees so commonly used in ",(0,o.jsx)(t.code,{children:"BrowserRouter"})," apps. This was explicitly to allow incremental migration from one to the other. Let's take a look at how we would do this."]}),"\n",(0,o.jsx)(t.h3,{id:"current-application",children:"Current Application"}),"\n",(0,o.jsx)(t.p,{children:"Let's assume we've got a current application with 2 descendant route trees, and assume these routes are all doing in-component data fetching, and rendering their own loading and error states."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",children:'import {\n  BrowserRouter,\n  Link,\n  Route,\n  Routes,\n} from "react-router-dom";\n\nexport default function App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path="/" element={<Home />} />\n        <Route path="/blog/*" element={<BlogApp />} />\n        <Route path="/users/*" element={<UserApp />} />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n\nfunction Home() {\n  return (\n    <>\n      <h1>Welcome!</h1>\n      <p>\n        Check out the <Link to="/blog">blog</Link> or the{" "}\n        <Link to="users">users</Link> section\n      </p>\n    </>\n  );\n}\n\nfunction BlogApp() {\n  return (\n    <Routes>\n      <Route index element={<h1>Blog Index</h1>} />\n      <Route path="posts" element={<h1>Blog Posts</h1>} />\n    </Routes>\n  );\n}\n\nfunction UserApp() {\n  return (\n    <Routes>\n      <Route index element={<h1>Users Index</h1>} />\n    </Routes>\n  );\n}\n'})}),"\n",(0,o.jsx)(t.h3,{id:"add-routerprovider-with-a-root-splat-route",children:"Add RouterProvider with a root splat route"}),"\n",(0,o.jsxs)(t.p,{children:["We can render this application inside a ",(0,o.jsx)(t.code,{children:"RouterProvider"})," with only a few small changes:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["Change your current ",(0,o.jsx)(t.code,{children:"App"})," component to ",(0,o.jsx)(t.code,{children:"Root"})]}),"\n",(0,o.jsxs)(t.li,{children:["Remove the ",(0,o.jsx)(t.code,{children:"<BrowserRouter>"})," component"]}),"\n",(0,o.jsxs)(t.li,{children:["Create a data router singleton with a splat route for the ",(0,o.jsx)(t.code,{children:"Root"})," element"]}),"\n",(0,o.jsxs)(t.li,{children:["Add a new ",(0,o.jsx)(t.code,{children:"App"})," component rendering a ",(0,o.jsx)(t.code,{children:"<RouterProvider>"})]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",metastring:"lines=[9-12,14-17,19-20,21-22]",children:'import {\n  createBrowserRouter,\n  Link,\n  Route,\n  RouterProvider,\n  Routes,\n} from "react-router-dom";\n\n// 3\ufe0f\u20e3 Router singleton created\nconst router = createBrowserRouter([\n  { path: "*", Component: Root },\n]);\n\n// 4\ufe0f\u20e3 RouterProvider added\nexport default function App() {\n  return <RouterProvider router={router} />;\n}\n\n// 1\ufe0f\u20e3 Changed from App to Root\nfunction Root() {\n  // 2\ufe0f\u20e3 `BrowserRouter` component removed, but the <Routes>/<Route>\n  // component below are unchanged\n  return (\n    <Routes>\n      <Route path="/" element={<Home />} />\n      <Route path="/blog/*" element={<BlogApp />} />\n      <Route path="/users/*" element={<UserApp />} />\n    </Routes>\n  );\n}\n\nfunction Home() {\n  /* Unchanged */\n}\nfunction BlogApp() {\n  /* Unchanged */\n}\nfunction UserApp() {\n  /* Unchanged */\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["\ud83e\udd73 Congrats - you're now rendering a data router app! But wait a minute - we can't use any of the new stuff yet since none of our routes are defined at the top with ",(0,o.jsx)(t.code,{children:"createBrowserRouter"})," \ud83d\ude22. To access the new APIs, we need to start lifting routes one-by-one to the data router."]}),"\n",(0,o.jsx)(t.h3,{id:"start-lifting-routes-and-leveraging-the-data-apis",children:"Start lifting routes and leveraging the data APIs"}),"\n",(0,o.jsxs)(t.p,{children:["Let's start with the ",(0,o.jsx)(t.code,{children:"/"})," route for the ",(0,o.jsx)(t.code,{children:"<Home>"})," component. All we need to do is lift the ",(0,o.jsx)(t.code,{children:"<Route>"})," definition up to the data router:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",metastring:"lines=[2,13]",children:'const router = createBrowserRouter([\n  { path: "/", Component: Home }, // \ud83c\udd95\n  { path: "*", Component: Root },\n]);\n\nexport default function App() {\n  return <RouterProvider router={router} />;\n}\n\nfunction Root() {\n  return (\n    <Routes>\n      {/* \u2b06\ufe0f Home route lifted up to the data router */}\n      <Route path="/blog/*" element={<BlogApp />} />\n      <Route path="/users/*" element={<UserApp />} />\n    </Routes>\n  );\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Now you can add data APIs to your home route (",(0,o.jsx)(t.code,{children:"loader"}),", ",(0,o.jsx)(t.code,{children:"action"}),", ",(0,o.jsx)(t.code,{children:"errorElement"}),") and start leveraging data hooks inside your Home component (",(0,o.jsx)(t.code,{children:"useLoaderData"}),", ",(0,o.jsx)(t.code,{children:"useActionData"}),", ",(0,o.jsx)(t.code,{children:"useFetcher"}),", ",(0,o.jsx)(t.code,{children:"<Form>"}),", etc.)."]}),"\n",(0,o.jsxs)(t.p,{children:["Now let's look at lifting the Blog App upwards, but still doing it one leaf route at a time. In order to lift the ",(0,o.jsx)(t.code,{children:"/blog"})," index route up, we need the ",(0,o.jsx)(t.code,{children:"/blog/*"})," splat route lifted as well, but we can still render the ",(0,o.jsx)(t.code,{children:"/blog/posts"})," route where it is and do that separately."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",metastring:"lines=[3-12,23,32]",children:'const router = createBrowserRouter([\n  { path: "/", Component: Home },\n  {\n    // Lifted blog splat route\n    path: "/blog/*",\n    children: [\n      // New blog index route\n      { index: true, Component: () => <h1>Blog Index</h1> },\n      // Blog subapp splat route added for /blog/posts matching\n      { path: "*", Component: BlogApp },\n    ],\n  },\n  { path: "*", Component: Root },\n]);\n\nexport default function App() {\n  return <RouterProvider router={router} />;\n}\n\nfunction Root() {\n  return (\n    <Routes>\n      {/* \u2b06\ufe0f Blog splat route lifted */}\n      <Route path="/users/*" element={<UserApp />} />\n    </Routes>\n  );\n}\n\nfunction BlogApp() {\n  return (\n    <Routes>\n      {/* \u2b06\ufe0f Blog index route lifted */}\n      <Route path="posts" element={<h1>Blog Posts</h1>} />\n    </Routes>\n  );\n}\n'})}),"\n",(0,o.jsx)(t.p,{children:"And now your blog index route can participate in data loading."}),"\n",(0,o.jsxs)(t.p,{children:["You can keep doing this one route at a time until you've eventually converted all of your routes to data routes and can no longer use any nested ",(0,o.jsx)(t.code,{children:"<Routes>"})," to define your routing tree. To avoid bundle bloat, it's recommended to leverage the ",(0,o.jsx)(t.a,{href:"../route/lazy",children:"route.lazy"})," prop to lazily load your routes."]}),"\n",(0,o.jsx)(t.h2,{id:"faq",children:"FAQ"}),"\n",(0,o.jsxs)(t.h3,{id:"but-ive-got-stuff-between-browserrouter-and-routes",children:["But I've got stuff between ",(0,o.jsx)(t.code,{children:"<BrowserRouter>"})," and ",(0,o.jsx)(t.code,{children:"<Routes>"})]}),"\n",(0,o.jsxs)(t.p,{children:["Many folks render an app shell around their ",(0,o.jsx)(t.code,{children:"<Routes>"})," via something like the following:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:'export default function App() {\n  return (\n    <BrowserRouter>\n      <header>\n        <h1>My Super Cool App</h1>\n        <NavMenu />\n      </header>\n      <main>\n        <Routes>\n          <Route path="/" element={<Home />} />\n          <Route path="/blog/*" element={<BlogApp />} />\n          <Route path="/users/*" element={<UserApp />} />\n        </Routes>\n      </main>\n      <footer>\xa9\ufe0f me 2023</footer>\n    </BrowserRouter>\n  );\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["If you find yourself in this situation, don't worry - there's a straightforward solution you can do ",(0,o.jsx)(t.em,{children:"before"})," starting the above migration."]}),"\n",(0,o.jsxs)(t.p,{children:["This is quite common but poses a problem in the above migration approach since we need to lift things to ",(0,o.jsx)(t.code,{children:"RouterProvider"}),' route-by-route, but this "app shell" stuff isn\'t part of a route...but it could be! That "app shell" is really nothing more than a layout route with an ',(0,o.jsx)(t.code,{children:"<Outlet>"}),'! So before starting the above migration, just move this "app shell" into a pathless layout route around your routes as follows:']}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",metastring:"lines=[6,25]",children:'export default function App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        {/* 1\ufe0f\u20e3 Wrap your routes in a pathless layout route */}\n        <Route element={<Layout />}>\n          <Route path="/" element={<Home />} />\n          <Route path="/blog/*" element={<BlogApp />} />\n          <Route path="/users/*" element={<UserApp />} />\n        </Route>\n      </Routes>\n    </BrowserRouter>\n  );\n}\n\nfunction Layout() {\n  return (\n    <>\n      <header>\n        <h1>My Super Cool App</h1>\n        <NavMenu />\n      </header>\n      <main>\n        {/* 2\ufe0f\u20e3 Render the app routes via the Layout Outlet */}\n        <Outlet />\n      </main>\n      <footer>\xa9\ufe0f me 2023</footer>\n    </>\n  );\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Once you've done that, you can proceed with the above migration strategy and start lifting routes into your ",(0,o.jsx)(t.code,{children:"RouterProvider"})," one-by-one. You'll likely want to lift the layout route first so all of the children can nest inside of it."]})]})}function c(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>i});var o=n(7294);const r={},s=o.createContext(r);function i(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);