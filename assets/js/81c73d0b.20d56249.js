"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2130],{9808:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var s=t(5893),a=t(1151);const r={title:"Main Concepts",order:5,sidebar_position:5},i="Main Concepts",o={id:"start/concepts",title:"Main Concepts",description:"This document needs to be updated for 6.4 data APIs",source:"@site/react-router/docs/start/concepts.md",sourceDirName:"start",slug:"/start/concepts",permalink:"/react-router-v6-searchable-docs/start/concepts",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1683639236,formattedLastUpdatedAt:"May 9, 2023",sidebarPosition:5,frontMatter:{title:"Main Concepts",order:5,sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"FAQs",permalink:"/react-router-v6-searchable-docs/start/faq"},next:{title:"Upgrading",permalink:"/react-router-v6-searchable-docs/upgrading/index"}},h={},c=[{value:"Definitions",id:"definitions",level:2},{value:"History and Locations",id:"history-and-locations",level:2},{value:"History Object",id:"history-object",level:3},{value:"Locations",id:"locations",level:3},{value:"Matching",id:"matching",level:2},{value:"Defining Routes",id:"defining-routes",level:3},{value:"Match Params",id:"match-params",level:3},{value:"Ranking Routes",id:"ranking-routes",level:3},{value:"Pathless Routes",id:"pathless-routes",level:3},{value:"Route Matches",id:"route-matches",level:3},{value:"Rendering",id:"rendering",level:2},{value:"Outlets",id:"outlets",level:3},{value:"Index Routes",id:"index-routes",level:3},{value:"Layout Routes",id:"layout-routes",level:3},{value:"Navigating",id:"navigating",level:2},{value:"Link",id:"link",level:3},{value:"Navigate Function",id:"navigate-function",level:3},{value:"Data Access",id:"data-access",level:2},{value:"Review",id:"review",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"main-concepts",children:"Main Concepts"}),"\n",(0,s.jsx)("docs-warning",{children:"This document needs to be updated for 6.4 data APIs"}),"\n",(0,s.jsxs)("docs-warning",{children:["This document is a deep dive into the core concepts behind routing as implemented in React Router. It's pretty long, so if you're looking for a more practical guide check out our ",(0,s.jsx)(n.a,{href:"./tutorial",children:"quick start tutorial"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["You might be wondering what exactly React Router does. How can it help you build your app? What exactly is a ",(0,s.jsx)(n.strong,{children:"router"}),", anyway?"]}),"\n",(0,s.jsx)(n.p,{children:"If you've ever had any of these questions, or you'd just like to dig into the fundamental pieces of routing, you're in the right place. This document contains detailed explanations of all the core concepts behind routing as implemented in React Router."}),"\n",(0,s.jsx)(n.p,{children:"Please don't let this document overwhelm you! For everyday use, React Router is pretty simple. You don't need to go this deep to use it."}),"\n",(0,s.jsx)(n.p,{children:"React Router isn't just about matching a url to a function or component: it's about building a full user interface that maps to the URL, so it might have more concepts in it than you're used to. We'll go into detail on the three main jobs of React Router:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Subscribing and manipulating the ",(0,s.jsx)(n.a,{href:"#history-stack",children:"history stack"})]}),"\n",(0,s.jsxs)(n.li,{children:["Matching the ",(0,s.jsx)(n.a,{href:"#url",children:"URL"})," to your ",(0,s.jsx)(n.a,{href:"#route-config",children:"routes"})]}),"\n",(0,s.jsxs)(n.li,{children:["Rendering a nested UI from the ",(0,s.jsx)(n.a,{href:"#matches",children:"route matches"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"definitions",children:"Definitions"}),"\n",(0,s.jsx)(n.p,{children:"But first, some definitions! There are a lot of different ideas around routing from back and front end frameworks. Sometimes a word in one context might have different meaning than another."}),"\n",(0,s.jsx)(n.p,{children:"Here are some words we use a lot when we talk about React Router. The rest of this guide will go into more detail on each one."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"url",children:(0,s.jsx)(n.strong,{children:"URL"})}),' - The URL in the address bar. A lot of people use the term "URL" and "route" interchangeably, but this is not a route in React Router, it\'s just a URL.']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"location",children:(0,s.jsx)(n.strong,{children:"Location"})})," - This is a React Router specific object that is based on the built-in browser's ",(0,s.jsx)(n.code,{children:"window.location"}),' object. It represents "where the user is at". It\'s mostly an object representation of the URL but has a bit more to it than that.']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"location-state",children:(0,s.jsx)(n.strong,{children:"Location State"})})," - A value that persists with a ",(0,s.jsx)(n.a,{href:"#location",children:"location"})," that isn't encoded in the ",(0,s.jsx)(n.a,{href:"#url",children:"URL"}),". Much like hash or search params (data encoded in the URL), but stored invisibly in the browser's memory."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"history-stack",children:(0,s.jsx)(n.strong,{children:"History Stack"})})," - As the user navigates, the browser keeps track of each ",(0,s.jsx)(n.a,{href:"#location",children:"location"})," in a stack. If you click and hold the back button in a browser you can see the browser's history stack right there."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"csr",children:(0,s.jsx)(n.strong,{children:"Client Side Routing (CSR)"})})," - A plain HTML document can link to other documents and the browser handles the ",(0,s.jsx)(n.a,{href:"#history-stack",children:"history stack"})," itself. Client Side Routing enables developers to manipulate the browser history stack without making a document request to the server."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"history",children:(0,s.jsx)(n.strong,{children:"History"})})," - An object that allows React Router to subscribe to changes in the ",(0,s.jsx)(n.a,{href:"#url",children:"URL"})," as well as providing APIs to manipulate the browser ",(0,s.jsx)(n.a,{href:"#history-stack",children:"history stack"})," programmatically."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"history-action",children:(0,s.jsx)(n.strong,{children:"History Action"})})," - One of ",(0,s.jsx)(n.code,{children:"POP"}),", ",(0,s.jsx)(n.code,{children:"PUSH"}),", or ",(0,s.jsx)(n.code,{children:"REPLACE"}),". Users can arrive at a ",(0,s.jsx)(n.a,{href:"#url",children:"URL"})," for one of these three reasons. A push when a new entry is added to the history stack (typically a link click or the programmer forced a navigation). A replace is similar except it replaces the current entry on the stack instead of pushing a new one. Finally, a pop happens when the user clicks the back or forward buttons in the browser chrome."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"segment",children:(0,s.jsx)(n.strong,{children:"Segment"})})," - The parts of a ",(0,s.jsx)(n.a,{href:"#url",children:"URL"})," or ",(0,s.jsx)(n.a,{href:"#path-pattern",children:"path pattern"})," between the ",(0,s.jsx)(n.code,{children:"/"}),' characters. For example, "/users/123" has two segments.']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"path-pattern",children:(0,s.jsx)(n.strong,{children:"Path Pattern"})})," - These look like URLs but can have special characters for matching URLs to routes, like ",(0,s.jsx)(n.strong,{children:"dynamic segments"})," (",(0,s.jsx)(n.code,{children:'"/users/:userId"'}),") or ",(0,s.jsx)(n.strong,{children:"star segments"})," (",(0,s.jsx)(n.code,{children:'"/docs/*"'}),"). They aren't URLs, they're patterns that React Router will match."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"dynamic-segment",children:(0,s.jsx)(n.strong,{children:"Dynamic Segment"})})," - A segment of a path pattern that is dynamic, meaning it can match any values in the segment. For example the pattern ",(0,s.jsx)(n.code,{children:"/users/:userId"})," will match URLs like ",(0,s.jsx)(n.code,{children:"/users/123"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"url-params",children:(0,s.jsx)(n.strong,{children:"URL Params"})})," - The parsed values from the URL that matched a ",(0,s.jsx)(n.a,{href:"#dynamic-segment",children:"dynamic segment"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"router",children:(0,s.jsx)(n.strong,{children:"Router"})})," - Stateful, top-level component that makes all the other components and hooks work."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"route-config",children:(0,s.jsx)(n.strong,{children:"Route Config"})})," - A tree of ",(0,s.jsx)(n.strong,{children:"routes objects"})," that will be ranked and matched (with nesting) against the current location to create a branch of ",(0,s.jsx)(n.strong,{children:"route matches"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"route",children:(0,s.jsx)(n.strong,{children:"Route"})})," - An object or Route Element typically with a shape of ",(0,s.jsx)(n.code,{children:"{ path, element }"})," or ",(0,s.jsx)(n.code,{children:"<Route path element>"}),". The ",(0,s.jsx)(n.code,{children:"path"})," is a path pattern. When the path pattern matches the current URL, the element will be rendered."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"route-element",children:(0,s.jsx)(n.strong,{children:"Route Element"})})," - Or ",(0,s.jsx)(n.code,{children:"<Route>"}),". This element's props are read to create a ",(0,s.jsx)(n.a,{href:"#route",children:"route"})," by ",(0,s.jsx)(n.code,{children:"<Routes>"}),", but otherwise does nothing."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"nested-routes",children:(0,s.jsx)(n.strong,{children:"Nested Routes"})})," - Because routes can have children and each route defines a portion of the ",(0,s.jsx)(n.a,{href:"#url",children:"URL"})," through ",(0,s.jsx)(n.a,{href:"#segment",children:"segments"}),', a single URL can match multiple routes in a nested "branch" of the tree. This enables automatic layout nesting through ',(0,s.jsx)(n.a,{href:"#outlet",children:"outlet"}),", ",(0,s.jsx)(n.a,{href:"#relative-links",children:"relative links"}),", and more."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"relative-links",children:(0,s.jsx)(n.strong,{children:"Relative links"})})," - Links that don't start with ",(0,s.jsx)(n.code,{children:"/"})," will inherit the closest route in which they are rendered. This makes it easy to link to deeper URLs without having to know and build up the entire path."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"match",children:(0,s.jsx)(n.strong,{children:"Match"})})," - An object that holds information when a route matches the URL, like the ",(0,s.jsx)(n.a,{href:"#url-params",children:"url params"})," and pathname that matched."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"matches",children:(0,s.jsx)(n.strong,{children:"Matches"})})," - An array of routes (or branch of the ",(0,s.jsx)(n.a,{href:"#route-config",children:"route config"}),") that matches the current ",(0,s.jsx)(n.a,{href:"#location",children:"location"}),". This structure enables ",(0,s.jsx)(n.a,{href:"#nested-routes",children:"nested routes"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"parent-route",children:(0,s.jsx)(n.strong,{children:"Parent Route"})})," - A route with child routes."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"outlet",children:(0,s.jsx)(n.strong,{children:"Outlet"})})," - A component that renders the next match in a set of ",(0,s.jsx)(n.a,{href:"#match",children:"matches"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"index-route",children:(0,s.jsx)(n.strong,{children:"Index Route"})})," - A child route with no path that renders in the parent's ",(0,s.jsx)(n.a,{href:"#outlet",children:"outlet"})," at the parent's ",(0,s.jsx)(n.a,{href:"#url",children:"URL"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{id:"layout-route",children:(0,s.jsx)(n.strong,{children:"Layout Route"})})," - A ",(0,s.jsx)(n.strong,{children:"parent route"})," without a path, used exclusively for grouping child routes inside a specific layout."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"history-and-locations",children:"History and Locations"}),"\n",(0,s.jsxs)(n.p,{children:["Before React Router can do anything, it has to be able to subscribe to changes in the browser ",(0,s.jsx)(n.a,{href:"#history-stack",children:"history stack"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Browsers maintain their own history stack as the user navigates around. That's how the back and forward buttons can work. In a traditional website (HTML documents without JavaScript) the browser will make requests to the server every time the user clicks a link, submits a form, or clicks the back and forward buttons."}),"\n",(0,s.jsx)(n.p,{children:"For example, consider the user:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["clicks a link to ",(0,s.jsx)(n.code,{children:"/dashboard"})]}),"\n",(0,s.jsxs)(n.li,{children:["clicks a link to ",(0,s.jsx)(n.code,{children:"/accounts"})]}),"\n",(0,s.jsxs)(n.li,{children:["clicks a link to ",(0,s.jsx)(n.code,{children:"/customers/123"})]}),"\n",(0,s.jsx)(n.li,{children:"clicks the back button"}),"\n",(0,s.jsxs)(n.li,{children:["clicks a link to ",(0,s.jsx)(n.code,{children:"/dashboard"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The history stack will change as follows where ",(0,s.jsx)(n.strong,{children:"bold"})," entries denote the current ",(0,s.jsx)(n.a,{href:"#url",children:"URL"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"/dashboard"})})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"/dashboard"}),", ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"/accounts"})})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"/dashboard"}),", ",(0,s.jsx)(n.code,{children:"/accounts"}),", ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"/customers/123"})})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"/dashboard"}),", ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"/accounts"})}),", ",(0,s.jsx)(n.code,{children:"/customers/123"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"/dashboard"}),", ",(0,s.jsx)(n.code,{children:"/accounts"}),", ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"/dashboard"})})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"history-object",children:"History Object"}),"\n",(0,s.jsxs)(n.p,{children:["With ",(0,s.jsx)(n.strong,{children:"client side routing"}),", developers are able to manipulate the browser ",(0,s.jsx)(n.a,{href:"#history-stack",children:"history stack"})," programmatically. For example, we can write some code like this to change the ",(0,s.jsx)(n.a,{href:"#url",children:"URL"})," without the browsers default behavior of making a request to the server:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'<a\n  href="/contact"\n  onClick={(event) => {\n    // stop the browser from changing the URL and requesting the new document\n    event.preventDefault();\n    // push an entry into the browser history stack and change the URL\n    window.history.pushState({}, undefined, "/contact");\n  }}\n/>\n'})}),"\n",(0,s.jsxs)("docs-warning",{children:["For illustration only, don't use ",(0,s.jsx)(n.code,{children:"window.history.pushState"})," directly in React Router"]}),"\n",(0,s.jsxs)(n.p,{children:["This code changes the ",(0,s.jsx)(n.a,{href:"#url",children:"URL"})," but doesn't do anything for the UI. We would need to write some more code that changed some state somewhere to get the UI to change to the contact page. The trouble is, the browser doesn't give us a way to \"listen to the URL\" and subscribe to changes like this."]}),"\n",(0,s.jsxs)(n.p,{children:["Well, that's not totally true. We can listen for changes to the URL via ",(0,s.jsx)(n.a,{href:"#history-actions",children:"pop"})," events:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'window.addEventListener("popstate", () => {\n  // URL changed!\n});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["But that only fires when the user clicks the back or forward buttons. There is no event for when the programmer called ",(0,s.jsx)(n.code,{children:"window.history.pushState"})," or ",(0,s.jsx)(n.code,{children:"window.history.replaceState"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["That's where a React Router specific ",(0,s.jsx)(n.code,{children:"history"}),' object comes into play. It provides a way to "listen for ',(0,s.jsx)(n.a,{href:"#url",children:"URL"}),'" changes whether the ',(0,s.jsx)(n.a,{href:"#history-actions",children:"history action"})," is ",(0,s.jsx)(n.strong,{children:"push"}),", ",(0,s.jsx)(n.strong,{children:"pop"}),", or ",(0,s.jsx)(n.strong,{children:"replace"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let history = createBrowserHistory();\nhistory.listen(({ location, action }) => {\n  // this is called whenever new locations come in\n  // the action is POP, PUSH, or REPLACE\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Apps don't need to set up their own history objects--that's the job of ",(0,s.jsx)(n.code,{children:"<Router>"}),". It sets up one of these objects, subscribe to changes in the ",(0,s.jsx)(n.a,{href:"#history-stack",children:"history stack"}),", and finally updates its state when the ",(0,s.jsx)(n.a,{href:"#url",children:"URL"})," changes. This causes the app to re-render and the correct UI to display. The only thing it needs to put on state is a ",(0,s.jsx)(n.code,{children:"location"}),", everything else works from that single object."]}),"\n",(0,s.jsx)(n.h3,{id:"locations",children:"Locations"}),"\n",(0,s.jsxs)(n.p,{children:["The browser has a location object on ",(0,s.jsx)(n.code,{children:"window.location"}),". It tells you information about the ",(0,s.jsx)(n.a,{href:"#url",children:"URL"})," but also has some methods to change it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"window.location.pathname; // /getting-started/concepts/\nwindow.location.hash; // #location\nwindow.location.reload(); // force a refresh w/ the server\n// and a lot more\n"})}),"\n",(0,s.jsxs)("docs-warning",{children:["For illustration. You don't typically work with ",(0,s.jsx)(n.code,{children:"window.location"})," in a React Router app"]}),"\n",(0,s.jsxs)(n.p,{children:["Instead of using ",(0,s.jsx)(n.code,{children:"window.location"}),", React Router has the concept of a ",(0,s.jsx)(n.a,{href:"#location",children:"location"})," that's patterned after ",(0,s.jsx)(n.code,{children:"window.location"})," but is much simpler. It looks like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  pathname: "/bbq/pig-pickins",\n  search: "?campaign=instagram",\n  hash: "#menu",\n  state: null,\n  key: "aefz24ie"\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The first three: ",(0,s.jsx)(n.code,{children:"{ pathname, search, hash }"})," are exactly like ",(0,s.jsx)(n.code,{children:"window.location"}),". If you just add up the three you'll get the ",(0,s.jsx)(n.a,{href:"#url",children:"URL"})," the user sees in the browser:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"location.pathname + location.search + location.hash;\n// /bbq/pig-pickins?campaign=instagram#menu\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The last two, ",(0,s.jsx)(n.code,{children:"{ state, key }"}),", are React Router specific."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Location Pathname"})}),"\n",(0,s.jsxs)(n.p,{children:["This is the part of ",(0,s.jsx)(n.a,{href:"#url",children:"URL"})," after the origin, so for ",(0,s.jsx)(n.code,{children:"https://example.com/teams/hotspurs"})," the pathname is ",(0,s.jsx)(n.code,{children:"/teams/hotspurs"}),". This is the only part of the location that routes match against."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Location Search"})}),"\n",(0,s.jsxs)(n.p,{children:["People use a lot of different terms for this part of the ",(0,s.jsx)(n.a,{href:"#url",children:"URL"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"location search"}),"\n",(0,s.jsx)(n.li,{children:"search params"}),"\n",(0,s.jsx)(n.li,{children:"URL search params"}),"\n",(0,s.jsx)(n.li,{children:"query string"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:['In React Router we call it the "location search". However, location search is a serialized version of ',(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams",children:(0,s.jsx)(n.code,{children:"URLSearchParams"})}),'. So sometimes we might call it "URL search params" as well.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// given a location like this:\nlet location = {\n  pathname: "/bbq/pig-pickins",\n  search: "?campaign=instagram&popular=true",\n  hash: "",\n  state: null,\n  key: "aefz24ie",\n};\n\n// we can turn the location.search into URLSearchParams\nlet params = new URLSearchParams(location.search);\nparams.get("campaign"); // "instagram"\nparams.get("popular"); // "true"\nparams.toString(); // "campaign=instagram&popular=true",\n'})}),"\n",(0,s.jsx)(n.p,{children:'When being precise, refer to the serialized string version as "search" and the parsed version as "search params", but it\'s common to use the terms interchangeably when precision isn\'t important.'}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Location Hash"})}),"\n",(0,s.jsxs)(n.p,{children:["Hashes in URLs indicate a scroll position ",(0,s.jsx)(n.em,{children:"on the current page"}),". Before the ",(0,s.jsx)(n.code,{children:"window.history.pushState"})," API was introduced, web developers did client side routing exclusively with the hash portion of the ",(0,s.jsx)(n.a,{href:"#url",children:"URL"}),", it was the only part we could manipulate without making a new request to the server. However, today we can use it for its designed purpose."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Location State"})}),"\n",(0,s.jsxs)(n.p,{children:["You may have wondered why the ",(0,s.jsx)(n.code,{children:"window.history.pushState()"}),' API is called "push state". State? Aren\'t we just changing the ',(0,s.jsx)(n.a,{href:"#url",children:"URL"}),"? Shouldn't it be ",(0,s.jsx)(n.code,{children:"history.push"}),"? Well, we weren't in the room when the API was designed, so we're not sure why \"state\" was the focus, but it is a cool feature of browsers nonetheless."]}),"\n",(0,s.jsxs)(n.p,{children:["Browsers let us persist information about a navigation by passing a value to ",(0,s.jsx)(n.code,{children:"pushState"}),". When the user clicks back, the value on ",(0,s.jsx)(n.code,{children:"history.state"}),' changes to whatever was "pushed" before.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'window.history.pushState("look ma!", undefined, "/contact");\nwindow.history.state; // "look ma!"\n// user clicks back\nwindow.history.state; // undefined\n// user clicks forward\nwindow.history.state; // "look ma!"\n'})}),"\n",(0,s.jsxs)("docs-warning",{children:["For illustration. You don't read ",(0,s.jsx)(n.code,{children:"history.state"})," directly in React Router apps"]}),"\n",(0,s.jsxs)(n.p,{children:["React Router takes advantage of this browser feature, abstracts it a bit, and surfaces the values on the ",(0,s.jsx)(n.code,{children:"location"})," instead of ",(0,s.jsx)(n.code,{children:"history"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["You can think about ",(0,s.jsx)(n.code,{children:"location.state"})," just like ",(0,s.jsx)(n.code,{children:"location.hash"})," or ",(0,s.jsx)(n.code,{children:"location.search"})," except instead of putting the values in the ",(0,s.jsx)(n.a,{href:"#url",children:"URL"})," it's hidden--like a super secret piece of the URL only the programmer knows about."]}),"\n",(0,s.jsx)(n.p,{children:"A couple of great use-cases for location state are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Telling the next page where the user came from and branching the UI. The most popular implementation here is showing a record in a modal if the user clicked on an item in a grid view, but if they show up to the URL directly, show the record in its own layout (pinterest, old instagram)."}),"\n",(0,s.jsx)(n.li,{children:"Sending a partial record from a list to the next screen so it can render the partial data immediately and then fetching the rest of the data afterward."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["You set location state in two ways: on ",(0,s.jsx)(n.code,{children:"<Link>"})," or ",(0,s.jsx)(n.code,{children:"navigate"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'<Link to="/pins/123" state={{ fromDashboard: true }} />;\n\nlet navigate = useNavigate();\nnavigate("/users/123", { state: partialUser });\n'})}),"\n",(0,s.jsxs)(n.p,{children:["And on the next page you can access it with ",(0,s.jsx)(n.code,{children:"useLocation"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"let location = useLocation();\nlocation.state;\n"})}),"\n",(0,s.jsxs)("docs-info",{children:["Location state values will get serialized, so something like ",(0,s.jsx)(n.code,{children:"new Date()"})," will be turned into a string."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Location Key"})}),"\n",(0,s.jsxs)(n.p,{children:["Each location gets a unique key. This is useful for advanced cases like location-based scroll management, client side data caching, and more. Because each new location gets a unique key, you can build abstractions that store information in a plain object, ",(0,s.jsx)(n.code,{children:"new Map()"}),", or even ",(0,s.jsx)(n.code,{children:"locationStorage"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, a very basic client side data cache could store values by location key (and the fetch ",(0,s.jsx)(n.a,{href:"#url",children:"URL"}),") and skip fetching the data when the user clicks back into it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'let cache = new Map();\n\nfunction useFakeFetch(URL) {\n  let location = useLocation();\n  let cacheKey = location.key + URL;\n  let cached = cache.get(cacheKey);\n\n  let [data, setData] = useState(() => {\n    // initialize from the cache\n    return cached || null;\n  });\n\n  let [state, setState] = useState(() => {\n    // avoid the fetch if cached\n    return cached ? "done" : "loading";\n  });\n\n  useEffect(() => {\n    if (state === "loading") {\n      let controller = new AbortController();\n      fetch(URL, { signal: controller.signal })\n        .then((res) => res.json())\n        .then((data) => {\n          if (controller.signal.aborted) return;\n          // set the cache\n          cache.set(cacheKey, data);\n          setData(data);\n        });\n      return () => controller.abort();\n    }\n  }, [state, cacheKey]);\n\n  useEffect(() => {\n    setState("loading");\n  }, [URL]);\n\n  return data;\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"matching",children:"Matching"}),"\n",(0,s.jsxs)(n.p,{children:["On the initial render, and when the ",(0,s.jsx)(n.a,{href:"#history-stack",children:"history stack"})," changes, React Router will match the ",(0,s.jsx)(n.a,{href:"#location",children:"location"})," against your ",(0,s.jsx)(n.a,{href:"#route-config",children:"route config"})," to come up with a set of ",(0,s.jsx)(n.a,{href:"#match",children:"matches"})," to render."]}),"\n",(0,s.jsx)(n.h3,{id:"defining-routes",children:"Defining Routes"}),"\n",(0,s.jsxs)(n.p,{children:["A route config is a tree of ",(0,s.jsx)(n.a,{href:"#route",children:"routes"})," that looks something like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'<Routes>\n  <Route path="/" element={<App />}>\n    <Route index element={<Home />} />\n    <Route path="teams" element={<Teams />}>\n      <Route path=":teamId" element={<Team />} />\n      <Route path=":teamId/edit" element={<EditTeam />} />\n      <Route path="new" element={<NewTeamForm />} />\n      <Route index element={<LeagueStandings />} />\n    </Route>\n  </Route>\n  <Route element={<PageLayout />}>\n    <Route path="/privacy" element={<Privacy />} />\n    <Route path="/tos" element={<Tos />} />\n  </Route>\n  <Route path="contact-us" element={<Contact />} />\n</Routes>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"<Routes>"})," component recurses through its ",(0,s.jsx)(n.code,{children:"props.children"}),", strips their props, and generates an object like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'let routes = [\n  {\n    element: <App />,\n    path: "/",\n    children: [\n      {\n        index: true,\n        element: <Home />,\n      },\n      {\n        path: "teams",\n        element: <Teams />,\n        children: [\n          {\n            index: true,\n            element: <LeagueStandings />,\n          },\n          {\n            path: ":teamId",\n            element: <Team />,\n          },\n          {\n            path: ":teamId/edit",\n            element: <EditTeam />,\n          },\n          {\n            path: "new",\n            element: <NewTeamForm />,\n          },\n        ],\n      },\n    ],\n  },\n  {\n    element: <PageLayout />,\n    children: [\n      {\n        element: <Privacy />,\n        path: "/privacy",\n      },\n      {\n        element: <Tos />,\n        path: "/tos",\n      },\n    ],\n  },\n  {\n    element: <Contact />,\n    path: "/contact-us",\n  },\n];\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In fact, instead of ",(0,s.jsx)(n.code,{children:"<Routes>"})," you can use the hook ",(0,s.jsx)(n.code,{children:"useRoutes(routesGoHere)"})," instead. That's all ",(0,s.jsx)(n.code,{children:"<Routes>"})," is doing."]}),"\n",(0,s.jsxs)(n.p,{children:["As you can see, routes can define multiple ",(0,s.jsx)(n.a,{href:"#segment",children:"segments"})," like ",(0,s.jsx)(n.code,{children:":teamId/edit"}),", or just one like ",(0,s.jsx)(n.code,{children:":teamId"}),". All of the segments down a branch of the ",(0,s.jsx)(n.a,{href:"#route-config",children:"route config"})," are added together to create a final ",(0,s.jsx)(n.a,{href:"#path-pattern",children:"path pattern"})," for a route."]}),"\n",(0,s.jsx)(n.h3,{id:"match-params",children:"Match Params"}),"\n",(0,s.jsxs)(n.p,{children:["Note the ",(0,s.jsx)(n.code,{children:":teamId"})," segments. This is what we call a ",(0,s.jsx)(n.a,{href:"#dynamic-segment",children:"dynamic segment"})," of the ",(0,s.jsx)(n.a,{href:"#path-pattern",children:"path pattern"}),", meaning it doesn't match the URL statically (the actual characters) but it matches it dynamically. Any value can fill in for ",(0,s.jsx)(n.code,{children:":teamId"}),". Both ",(0,s.jsx)(n.code,{children:"/teams/123"})," or ",(0,s.jsx)(n.code,{children:"/teams/cupcakes"})," will match. We call the parsed values ",(0,s.jsx)(n.a,{href:"#url-params",children:"URL params"}),". So in this case our ",(0,s.jsx)(n.code,{children:"teamId"})," param would be ",(0,s.jsx)(n.code,{children:'"123"'})," or ",(0,s.jsx)(n.code,{children:'"cupcakes"'}),". We'll see how to use them in your app in the ",(0,s.jsx)(n.a,{href:"#rendering",children:"Rendering"})," section."]}),"\n",(0,s.jsx)(n.h3,{id:"ranking-routes",children:"Ranking Routes"}),"\n",(0,s.jsxs)(n.p,{children:["If we add up all the segments of all the branches of our ",(0,s.jsx)(n.a,{href:"#route-config",children:"route config"}),", we end up with the following path patterns that our app responds to:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'[\n  "/",\n  "/teams",\n  "/teams/:teamId",\n  "/teams/:teamId/edit",\n  "/teams/new",\n  "/privacy",\n  "/tos",\n  "/contact-us",\n];\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Now this is where things get really interesting. Consider the ",(0,s.jsx)(n.a,{href:"#url",children:"URL"})," ",(0,s.jsx)(n.code,{children:"/teams/new"}),". Which pattern in that list matches the URL?"]}),"\n",(0,s.jsx)(n.p,{children:"That's right, two of them!"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"/teams/new\n/teams/:teamId\n"})}),"\n",(0,s.jsxs)(n.p,{children:["React Router has to make a decision here, there can be only one. Many routers, both client side and server side, will simply process the patterns in the order in which they were defined. First to match wins. In this case we would match ",(0,s.jsx)(n.code,{children:"/"})," and render the ",(0,s.jsx)(n.code,{children:"<Home/>"})," component. Definitely not what we wanted. These kinds of routers require us to order our routes perfectly to get the expected result. This is how React Router has worked up until v6, but now it's much smarter."]}),"\n",(0,s.jsxs)(n.p,{children:["Looking at those patterns, you intuitively know that we want ",(0,s.jsx)(n.code,{children:"/teams/new"})," to match the URL ",(0,s.jsx)(n.code,{children:"/teams/new"}),". It's a perfect match! React Router also knows that. When matching, it will rank your routes according the number of segments, static segments, dynamic segments, star patterns, etc. and pick the most specific match. You'll never have to think about ordering your routes."]}),"\n",(0,s.jsx)(n.h3,{id:"pathless-routes",children:"Pathless Routes"}),"\n",(0,s.jsx)(n.p,{children:"You may have noticed the weird routes from earlier:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<Route index element={<Home />} />\n<Route index element={<LeagueStandings />} />\n<Route element={<PageLayout />} />\n"})}),"\n",(0,s.jsxs)(n.p,{children:['They don\'t even have a path, how can they be a route? This is where the word "route" in React Router is used pretty loosely. ',(0,s.jsx)(n.code,{children:"<Home/>"})," and ",(0,s.jsx)(n.code,{children:"<LeagueStandings/>"})," are ",(0,s.jsx)(n.a,{href:"#index-route",children:"index routes"})," and ",(0,s.jsx)(n.code,{children:"<PageLayout/>"})," is a ",(0,s.jsx)(n.a,{href:"#layout-route",children:"layout route"}),". We'll discuss how they work in the ",(0,s.jsx)(n.a,{href:"#rendering",children:"Rendering"})," section. Neither really has much to do with matching."]}),"\n",(0,s.jsx)(n.h3,{id:"route-matches",children:"Route Matches"}),"\n",(0,s.jsxs)(n.p,{children:["When a route matches the URL, it's represented by a ",(0,s.jsx)(n.a,{href:"#match",children:"match"})," object. A match for ",(0,s.jsx)(n.code,{children:'<Route path=":teamId" element={<Team/>}/>'})," would look something like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  pathname: "/teams/firebirds",\n  params: {\n    teamId: "firebirds"\n  },\n  route: {\n    element: <Team />,\n    path: ":teamId"\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"pathname"})," holds the portion of the URL that matched this route (in our case it's all of it). ",(0,s.jsx)(n.code,{children:"params"})," holds the parsed values from any ",(0,s.jsx)(n.a,{href:"#dynamic-segment",children:"dynamic segments"})," that matched. Note that the param's object keys map directly to the name of the segment: ",(0,s.jsx)(n.code,{children:":teamId"})," becomes ",(0,s.jsx)(n.code,{children:"params.teamId"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Because our routes are a tree, a single URL can match an entire branch of the tree. Consider the URL ",(0,s.jsx)(n.code,{children:"/teams/firebirds"}),", it would be the following route branch:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",metastring:"[2,4,5]",children:'<Routes>\n  <Route path="/" element={<App />}>\n    <Route index element={<Home />} />\n    <Route path="teams" element={<Teams />}>\n      <Route path=":teamId" element={<Team />} />\n      <Route path=":teamId/edit" element={<EditTeam />} />\n      <Route path="new" element={<NewTeamForm />} />\n      <Route index element={<LeagueStandings />} />\n    </Route>\n  </Route>\n  <Route element={<PageLayout />}>\n    <Route path="/privacy" element={<Privacy />} />\n    <Route path="/tos" element={<Tos />} />\n  </Route>\n  <Route path="contact-us" element={<Contact />} />\n</Routes>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["React Router will create an array of ",(0,s.jsx)(n.a,{href:"#match",children:"matches"})," from these routes and the url so it can render a nested UI that matches the route nesting."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'[\n  {\n    pathname: "/",\n    params: null,\n    route: {\n      element: <App />,\n      path: "/",\n    },\n  },\n  {\n    pathname: "/teams",\n    params: null,\n    route: {\n      element: <Teams />,\n      path: "teams",\n    },\n  },\n  {\n    pathname: "/teams/firebirds",\n    params: {\n      teamId: "firebirds",\n    },\n    route: {\n      element: <Team />,\n      path: ":teamId",\n    },\n  },\n];\n'})}),"\n",(0,s.jsx)(n.h2,{id:"rendering",children:"Rendering"}),"\n",(0,s.jsx)(n.p,{children:"The final concept is rendering. Consider that the entry to your app looks like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'const root = ReactDOM.createRoot(\n  document.getElementById("root")\n);\nroot.render(\n  <BrowserRouter>\n    <Routes>\n      <Route path="/" element={<App />}>\n        <Route index element={<Home />} />\n        <Route path="teams" element={<Teams />}>\n          <Route path=":teamId" element={<Team />} />\n          <Route path="new" element={<NewTeamForm />} />\n          <Route index element={<LeagueStandings />} />\n        </Route>\n      </Route>\n      <Route element={<PageLayout />}>\n        <Route path="/privacy" element={<Privacy />} />\n        <Route path="/tos" element={<Tos />} />\n      </Route>\n      <Route path="contact-us" element={<Contact />} />\n    </Routes>\n  </BrowserRouter>\n);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Let's use the ",(0,s.jsx)(n.code,{children:"/teams/firebirds"})," URL as an example again. ",(0,s.jsx)(n.code,{children:"<Routes>"})," will match the ",(0,s.jsx)(n.a,{href:"#location",children:"location"})," to your ",(0,s.jsx)(n.a,{href:"#route-config",children:"route config"}),", get a set of ",(0,s.jsx)(n.a,{href:"#match",children:"matches"}),", and then render a React element tree like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<App>\n  <Teams>\n    <Team />\n  </Teams>\n</App>\n"})}),"\n",(0,s.jsx)(n.p,{children:"Each match rendered inside the parent route's element is a really powerful abstraction. Most websites and apps share this characteristic: boxes inside of boxes inside of boxes, each with a navigation section that changes a child section of the page."}),"\n",(0,s.jsx)(n.h3,{id:"outlets",children:"Outlets"}),"\n",(0,s.jsxs)(n.p,{children:["This nested element tree won't happen automatically. ",(0,s.jsx)(n.code,{children:"<Routes>"})," will render the first match's element for you (In our case that's ",(0,s.jsx)(n.code,{children:"<App/>"}),"). The next match's element is ",(0,s.jsx)(n.code,{children:"<Teams>"}),". In order to render that, ",(0,s.jsx)(n.code,{children:"App"})," needs to render an ",(0,s.jsx)(n.a,{href:"#outlet",children:"outlet"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",metastring:"[5]",children:"function App() {\n  return (\n    <div>\n      <GlobalNav />\n      <Outlet />\n      <GlobalFooter />\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Outlet"})," component will always render the next match. That means ",(0,s.jsx)(n.code,{children:"<Teams>"})," also needs an outlet to render ",(0,s.jsx)(n.code,{children:"<Team/>"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If the URL were ",(0,s.jsx)(n.code,{children:"/contact-us"}),", the element tree would change to:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<ContactForm />\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Because the contact form is not under the main ",(0,s.jsx)(n.code,{children:"<App>"})," route."]}),"\n",(0,s.jsxs)(n.p,{children:["If the URL were ",(0,s.jsx)(n.code,{children:"/teams/firebirds/edit"}),", the element tree would change to:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<App>\n  <Teams>\n    <EditTeam />\n  </Teams>\n</App>\n"})}),"\n",(0,s.jsx)(n.p,{children:"The outlet swaps out the child for the new child that matches, but the parent layout persists. It's subtle but very effective at cleaning up your components."}),"\n",(0,s.jsx)(n.h3,{id:"index-routes",children:"Index Routes"}),"\n",(0,s.jsxs)(n.p,{children:["Remember the ",(0,s.jsx)(n.a,{href:"#route-config",children:"route config"})," for ",(0,s.jsx)(n.code,{children:"/teams"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'<Route path="teams" element={<Teams />}>\n  <Route path=":teamId" element={<Team />} />\n  <Route path="new" element={<NewTeamForm />} />\n  <Route index element={<LeagueStandings />} />\n</Route>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If the URL were ",(0,s.jsx)(n.code,{children:"/teams/firebirds"}),", the element tree would be:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<App>\n  <Teams>\n    <Team />\n  </Teams>\n</App>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["But if the URL were ",(0,s.jsx)(n.code,{children:"/teams"}),", the element tree would be:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<App>\n  <Teams>\n    <LeagueStandings />\n  </Teams>\n</App>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["League standings? How the heck did ",(0,s.jsx)(n.code,{children:"<Route index element={<LeagueStandings>}/>"})," pop in there? It doesn't even have a path! The reason is that it's an ",(0,s.jsx)(n.a,{href:"#index-route",children:"index route"}),". Index routes render in their parent route's ",(0,s.jsx)(n.a,{href:"#outlet",children:"outlet"})," at the parent route's path."]}),"\n",(0,s.jsxs)(n.p,{children:["Think of it this way, if you're not at one of the child routes' paths, the ",(0,s.jsx)(n.code,{children:"<Outlet>"})," will render nothing in the UI:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<App>\n  <Teams />\n</App>\n"})}),"\n",(0,s.jsx)(n.p,{children:"If all the teams are in a list on the left then an empty outlet means you've got a blank page on the right! Your UI needs something to fill the space: index routes to the rescue."}),"\n",(0,s.jsx)(n.p,{children:"Another way to think of an index route is that it's the default child route when the parent matches but none of its children do."}),"\n",(0,s.jsx)(n.p,{children:"Depending on the user interface, you might not need an index route, but if there is any sort of persistent navigation in the parent route you'll most likely want an index route to fill the space when the user hasn't clicked one of the items yet."}),"\n",(0,s.jsx)(n.h3,{id:"layout-routes",children:"Layout Routes"}),"\n",(0,s.jsxs)(n.p,{children:["Here's a part of our route config we haven't matched yet: ",(0,s.jsx)(n.code,{children:"/privacy"}),". Let's look at the route config again, highlighting the matched routes:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",metastring:"[2,11,12]",children:'<Routes>\n  <Route path="/" element={<App />}>\n    <Route index element={<Home />} />\n    <Route path="teams" element={<Teams />}>\n      <Route path=":teamId" element={<Team />} />\n      <Route path=":teamId/edit" element={<EditTeam />} />\n      <Route path="new" element={<NewTeamForm />} />\n      <Route index element={<LeagueStandings />} />\n    </Route>\n  </Route>\n  <Route element={<PageLayout />}>\n    <Route path="/privacy" element={<Privacy />} />\n    <Route path="/tos" element={<Tos />} />\n  </Route>\n  <Route path="contact-us" element={<Contact />} />\n</Routes>\n'})}),"\n",(0,s.jsx)(n.p,{children:"And the resulting element tree rendered will be:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<PageLayout>\n  <Privacy />\n</PageLayout>\n"})}),"\n",(0,s.jsxs)("docs-warning",{children:["Don't forget to add an ",(0,s.jsx)(n.code,{children:"<Outlet>"})," to your layout where you would like child route elements to be rendered. Using ",(0,s.jsx)(n.code,{children:"{children}"})," will not work as expected."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"PageLayout"})," route is admittedly weird. We call it a ",(0,s.jsx)(n.a,{href:"#layout-route",children:"layout route"})," because it doesn't participate in the matching at all (though its children do). It only exists to make wrapping multiple child routes in the same layout simpler. If we didn't allow this then you'd have to handle layouts in two different ways: sometimes your routes do it for you, sometimes you do it manually with lots of layout component repetition throughout your app:"]}),"\n",(0,s.jsx)("docs-error",{children:"You can do it like this, but we recommend using a layout route"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",metastring:"bad lines=[14-16,22-24]",children:'<Routes>\n  <Route path="/" element={<App />}>\n    <Route index element={<Home />} />\n    <Route path="teams" element={<Teams />}>\n      <Route path=":teamId" element={<Team />} />\n      <Route path=":teamId/edit" element={<EditTeam />} />\n      <Route path="new" element={<NewTeamForm />} />\n      <Route index element={<LeagueStandings />} />\n    </Route>\n  </Route>\n  <Route\n    path="/privacy"\n    element={\n      <PageLayout>\n        <Privacy />\n      </PageLayout>\n    }\n  />\n  <Route\n    path="/tos"\n    element={\n      <PageLayout>\n        <Tos />\n      </PageLayout>\n    }\n  />\n  <Route path="contact-us" element={<Contact />} />\n</Routes>\n'})}),"\n",(0,s.jsx)(n.p,{children:'So, yeah, the semantics of a layout "route" is a bit silly since it has nothing to do with the URL matching, but it\'s just too convenient to disallow.'}),"\n",(0,s.jsx)(n.h2,{id:"navigating",children:"Navigating"}),"\n",(0,s.jsxs)(n.p,{children:["When the ",(0,s.jsx)(n.a,{href:"#url",children:"URL"}),' changes we call that a "navigation". There are two ways to navigate in React Router:']}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"<Link>"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"navigate"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"link",children:"Link"}),"\n",(0,s.jsxs)(n.p,{children:["This is the primary means of navigation. Rendering a ",(0,s.jsx)(n.code,{children:"<Link>"})," allows the user to change the URL when they click it. React Router will prevent the browser's default behavior and tell the ",(0,s.jsx)(n.a,{href:"#history",children:"history"})," to push a new entry into the ",(0,s.jsx)(n.a,{href:"#history-stack",children:"history stack"}),". The ",(0,s.jsx)(n.a,{href:"#location",children:"location"})," changes and the new ",(0,s.jsx)(n.a,{href:"#match",children:"matches"})," will render."]}),"\n",(0,s.jsx)(n.p,{children:"However, links are accessible in that they:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Still render a ",(0,s.jsx)(n.code,{children:"<a href>"})," so all default accessibility concerns are met (like keyboard, focusability, SEO, etc.)"]}),"\n",(0,s.jsx)(n.li,{children:"Don't prevent the browser's default behavior if it's a right click or command/control click to \"open in new tab\""}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"#nested-routes",children:"Nested routes"}),' aren\'t just about rendering layouts; they also enable "relative links". Consider our ',(0,s.jsx)(n.code,{children:"teams"})," route from before:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'<Route path="teams" element={<Teams />}>\n  <Route path=":teamId" element={<Team />} />\n</Route>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"<Teams>"})," component can render links like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'<Link to="psg" />\n<Link to="new" />\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The full path it links to will be ",(0,s.jsx)(n.code,{children:"/teams/psg"})," and ",(0,s.jsx)(n.code,{children:"/teams/new"}),". They inherit the route within which they are rendered. This makes it so your route components don't have to really know anything about the rest of the routes in the app. A very large amount of links just go one more ",(0,s.jsx)(n.a,{href:"#segment",children:"segment"})," deeper. You can rearrange your whole ",(0,s.jsx)(n.a,{href:"#route-config",children:"route config"})," and these links will likely still work just fine. This is very valuable when building out a site in the beginning and the designs and layouts are shifting around."]}),"\n",(0,s.jsx)(n.h3,{id:"navigate-function",children:"Navigate Function"}),"\n",(0,s.jsxs)(n.p,{children:["This function is returned from the ",(0,s.jsx)(n.code,{children:"useNavigate"})," hook and allows you, the programmer, to change the URL whenever you want. You could do it on a timeout:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'let navigate = useNavigate();\nuseEffect(() => {\n  setTimeout(() => {\n    navigate("/logout");\n  }, 30000);\n}, []);\n'})}),"\n",(0,s.jsx)(n.p,{children:"Or after a form is submitted:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'<form onSubmit={event => {\n  event.preventDefault();\n  let data = new FormData(event.target)\n  let urlEncoded = new URLSearchParams(data)\n  navigate("/create", { state: urlEncoded })\n}}>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Like ",(0,s.jsx)(n.code,{children:"Link"}),", ",(0,s.jsx)(n.code,{children:"navigate"}),' works with nested "to" values as well.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'navigate("psg");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You should have a good reason to use ",(0,s.jsx)(n.code,{children:"navigate"})," instead of ",(0,s.jsx)(n.code,{children:"<Link>"}),". This makes us very sad:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:"bad nonumber",children:'<li onClick={() => navigate("/somewhere")} />\n'})}),"\n",(0,s.jsx)(n.p,{children:"Aside from links and forms, very few interactions should change the URL because it introduces complexity around accessibility and user expectations."}),"\n",(0,s.jsx)(n.h2,{id:"data-access",children:"Data Access"}),"\n",(0,s.jsx)(n.p,{children:"Finally, an application is going to want to ask React Router for a few pieces of information in order to build out the full UI. For this, React Router has a pile of hooks"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let location = useLocation();\nlet urlParams = useParams();\nlet [urlSearchParams] = useSearchParams();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"review",children:"Review"}),"\n",(0,s.jsx)(n.p,{children:"Let's put it all together from the top!"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"You render your app:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'const root = ReactDOM.createRoot(\n  document.getElementById("root")\n);\nroot.render(\n  <BrowserRouter>\n    <Routes>\n      <Route path="/" element={<App />}>\n        <Route index element={<Home />} />\n        <Route path="teams" element={<Teams />}>\n          <Route path=":teamId" element={<Team />} />\n          <Route path="new" element={<NewTeamForm />} />\n          <Route index element={<LeagueStandings />} />\n        </Route>\n      </Route>\n      <Route element={<PageLayout />}>\n        <Route path="/privacy" element={<Privacy />} />\n        <Route path="/tos" element={<Tos />} />\n      </Route>\n      <Route path="contact-us" element={<Contact />} />\n    </Routes>\n  </BrowserRouter>\n);\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<BrowserRouter>"})," creates a ",(0,s.jsx)(n.a,{href:"#history",children:"history"}),", puts the initial ",(0,s.jsx)(n.a,{href:"#location",children:"location"})," in to state, and subscribes to the ",(0,s.jsx)(n.a,{href:"#url",children:"URL"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<Routes>"})," recurses its ",(0,s.jsx)(n.a,{href:"#child-route",children:"child routes"})," to build a ",(0,s.jsx)(n.a,{href:"#route-config",children:"route config"}),", matches those routes against the ",(0,s.jsx)(n.a,{href:"#location",children:"location"}),", creates some route ",(0,s.jsx)(n.a,{href:"#match",children:"matches"}),", and renders the first match's route element."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["You render an ",(0,s.jsx)(n.a,{href:"#outlet",children:(0,s.jsx)(n.code,{children:"<Outlet/>"})})," in each ",(0,s.jsx)(n.a,{href:"#parent-route",children:"parent route"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The outlets render the next match in the route ",(0,s.jsx)(n.a,{href:"#match",children:"matches"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The user clicks a link"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The link calls ",(0,s.jsx)(n.code,{children:"navigate()"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"#history",children:"history"})," changes the URL and notifies ",(0,s.jsx)(n.code,{children:"<BrowserRouter>"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<BrowserRouter>"})," rerenders, start over at (2)!"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"That's it! We hope this guide has helped you gain a deeper understanding of the main concepts in React Router."})]})}function d(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>i});var s=t(7294);const a={},r=s.createContext(a);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);