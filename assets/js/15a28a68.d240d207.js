"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3277],{6150:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var r=t(5893),s=t(1151);const a={title:"Feature Overview",order:1,sidebar_position:1},i="Feature Overview",o={id:"start/overview",title:"Feature Overview",description:"Client Side Routing",source:"@site/react-router/docs/start/overview.md",sourceDirName:"start",slug:"/start/overview",permalink:"/react-router-v6-searchable-docs/start/overview",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1685197769,formattedLastUpdatedAt:"May 27, 2023",sidebarPosition:1,frontMatter:{title:"Feature Overview",order:1,sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Getting Started",permalink:"/react-router-v6-searchable-docs/start/index"},next:{title:"Tutorial",permalink:"/react-router-v6-searchable-docs/start/tutorial"}},c={},l=[{value:"Client Side Routing",id:"client-side-routing",level:2},{value:"Nested Routes",id:"nested-routes",level:2},{value:"Dynamic Segments",id:"dynamic-segments",level:2},{value:"Ranked Route Matching",id:"ranked-route-matching",level:2},{value:"Active Links",id:"active-links",level:2},{value:"Relative Links",id:"relative-links",level:2},{value:"Data Loading",id:"data-loading",level:2},{value:"Redirects",id:"redirects",level:2},{value:"Pending Navigation UI",id:"pending-navigation-ui",level:2},{value:"Skeleton UI with <code>&lt;Suspense&gt;</code>",id:"skeleton-ui-with-suspense",level:2},{value:"Data Mutations",id:"data-mutations",level:2},{value:"Data Revalidation",id:"data-revalidation",level:2},{value:"Busy Indicators",id:"busy-indicators",level:2},{value:"Optimistic UI",id:"optimistic-ui",level:2},{value:"Data Fetchers",id:"data-fetchers",level:2},{value:"Race Condition Handling",id:"race-condition-handling",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Scroll Restoration",id:"scroll-restoration",level:2},{value:"Web Standard APIs",id:"web-standard-apis",level:2},{value:"Search Params",id:"search-params",level:2},{value:"Location State",id:"location-state",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"feature-overview",children:"Feature Overview"}),"\n",(0,r.jsx)(n.h2,{id:"client-side-routing",children:"Client Side Routing"}),"\n",(0,r.jsx)(n.p,{children:'React Router enables "client side routing".'}),"\n",(0,r.jsx)(n.p,{children:"In traditional websites, the browser requests a document from a web server, downloads and evaluates CSS and JavaScript assets, and renders the HTML sent from the server. When the user clicks a link, it starts the process all over again for a new page."}),"\n",(0,r.jsxs)(n.p,{children:["Client side routing allows your app to update the URL from a link click without making another request for another document from the server. Instead, your app can immediately render some new UI and make data requests with ",(0,r.jsx)(n.code,{children:"fetch"})," to update the page with new information."]}),"\n",(0,r.jsx)(n.p,{children:"This enables faster user experiences because the browser doesn't need to request an entirely new document or re-evaluate CSS and JavaScript assets for the next page. It also enables more dynamic user experiences with things like animation."}),"\n",(0,r.jsxs)(n.p,{children:["Client side routing is enabled by creating a ",(0,r.jsx)(n.code,{children:"Router"})," and linking/submitting to pages with ",(0,r.jsx)(n.code,{children:"Link"})," and ",(0,r.jsx)(n.code,{children:"<Form>"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:"[10,16,27]",children:'import * as React from "react";\nimport { createRoot } from "react-dom/client";\nimport {\n  createBrowserRouter,\n  RouterProvider,\n  Route,\n  Link,\n} from "react-router-dom";\n\nconst router = createBrowserRouter([\n  {\n    path: "/",\n    element: (\n      <div>\n        <h1>Hello World</h1>\n        <Link to="about">About Us</Link>\n      </div>\n    ),\n  },\n  {\n    path: "about",\n    element: <div>About</div>,\n  },\n]);\n\ncreateRoot(document.getElementById("root")).render(\n  <RouterProvider router={router} />\n);\n'})}),"\n",(0,r.jsx)(n.h2,{id:"nested-routes",children:"Nested Routes"}),"\n",(0,r.jsx)(n.p,{children:"Nested Routing is the general idea of coupling segments of the URL to component hierarchy and data. React Router's nested routes were inspired by the routing system in Ember.js circa 2014. The Ember team realized that in nearly every case, segments of the URL determine:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The layouts to render on the page"}),"\n",(0,r.jsx)(n.li,{children:"The data dependencies of those layouts"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"React Router embraces this convention with APIs for creating nested layouts coupled to URL segments and data."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'// Configure nested routes with JSX\ncreateBrowserRouter(\n  createRoutesFromElements(\n    <Route path="/" element={<Root />}>\n      <Route path="contact" element={<Contact />} />\n      <Route\n        path="dashboard"\n        element={<Dashboard />}\n        loader={({ request }) =>\n          fetch("/api/dashboard.json", {\n            signal: request.signal,\n          })\n        }\n      />\n      <Route element={<AuthLayout />}>\n        <Route\n          path="login"\n          element={<Login />}\n          loader={redirectIfUser}\n        />\n        <Route path="logout" action={logoutUser} />\n      </Route>\n    </Route>\n  )\n);\n\n// Or use plain objects\ncreateBrowserRouter([\n  {\n    path: "/",\n    element: <Root />,\n    children: [\n      {\n        path: "contact",\n        element: <Contact />,\n      },\n      {\n        path: "dashboard",\n        element: <Dashboard />,\n        loader: ({ request }) =>\n          fetch("/api/dashboard.json", {\n            signal: request.signal,\n          }),\n      },\n      {\n        element: <AuthLayout />,\n        children: [\n          {\n            path: "login",\n            element: <Login />,\n            loader: redirectIfUser,\n          },\n          {\n            path: "logout",\n            action: logoutUser,\n          },\n        ],\n      },\n    ],\n  },\n]);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This ",(0,r.jsx)(n.a,{href:"https://remix.run/_docs/routing",children:"visualization"})," might be helpful."]}),"\n",(0,r.jsx)(n.h2,{id:"dynamic-segments",children:"Dynamic Segments"}),"\n",(0,r.jsx)(n.p,{children:"Segments of the URL can be dynamic placeholders that are parsed and provided to various apis."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Route path="projects/:projectId/tasks/:taskId" />\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The two segments with ",(0,r.jsx)(n.code,{children:":"})," are dynamic, and provided to the following APIs:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'// If the current location is /projects/abc/tasks/3\n<Route\n  // sent to loaders\n  loader={({ params }) => {\n    params.projectId; // abc\n    params.taskId; // 3\n  }}\n  // and actions\n  action={({ params }) => {\n    params.projectId; // abc\n    params.taskId; // 3\n  }}\n  element={<Task />}\n/>;\n\nfunction Task() {\n  // returned from `useParams`\n  const params = useParams();\n  params.projectId; // abc\n  params.taskId; // 3\n}\n\nfunction Random() {\n  const match = useMatch(\n    "/projects/:projectId/tasks/:taskId"\n  );\n  match.params.projectId; // abc\n  match.params.taskId; // 3\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"See:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../route/route#path",children:(0,r.jsx)(n.code,{children:"<Route path>"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../route/loader",children:(0,r.jsx)(n.code,{children:"<Route loader>"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../route/action",children:(0,r.jsx)(n.code,{children:"<Route action>"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../hooks/use-params",children:(0,r.jsx)(n.code,{children:"useParams"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../hooks/use-match",children:(0,r.jsx)(n.code,{children:"useMatch"})})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"ranked-route-matching",children:"Ranked Route Matching"}),"\n",(0,r.jsxs)(n.p,{children:["When matching URLs to routes, React Router will rank the routes according to the number of segments, static segments, dynamic segments, splats, etc. and pick the ",(0,r.jsx)(n.em,{children:"most specific"})," match."]}),"\n",(0,r.jsx)(n.p,{children:"For example, consider these two routes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Route path="/teams/:teamId" />\n<Route path="/teams/new" />\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Now consider the URL is ",(0,r.jsx)(n.a,{href:"http://example.com/teams/new",children:"http://example.com/teams/new"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Even though both routes technically match the URL (",(0,r.jsx)(n.code,{children:"new"})," could be the ",(0,r.jsx)(n.code,{children:":teamId"}),"), you intuitively know that we want the second route (",(0,r.jsx)(n.code,{children:"/teams/new"}),") to be picked. React Router's matching algorithm knows that, too."]}),"\n",(0,r.jsx)(n.p,{children:"With ranked routes, you don't have to worry about route ordering."}),"\n",(0,r.jsx)(n.h2,{id:"active-links",children:"Active Links"}),"\n",(0,r.jsxs)(n.p,{children:["Most web apps have persistent navigation sections at the top of the UI, the sidebar, and often multiple levels. Styling the active navigation items so the user knows where they are (",(0,r.jsx)(n.code,{children:"isActive"}),") or where they're going (",(0,r.jsx)(n.code,{children:"isPending"}),") in the app is done easily with ",(0,r.jsx)(n.code,{children:"<NavLink>"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<NavLink\n  style={({ isActive, isPending }) => {\n    return {\n      color: isActive ? "red" : "inherit",\n    };\n  }}\n  className={({ isActive, isPending }) => {\n    return isActive ? "active" : isPending ? "pending" : "";\n  }}\n/>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["You can also ",(0,r.jsx)(n.a,{href:"../hooks/use-match",children:(0,r.jsx)(n.code,{children:"useMatch"})}),' for any other "active" indication outside of links.']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'function SomeComp() {\n  const match = useMatch("/messages");\n  return <li className={Boolean(match) ? "active" : ""} />;\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"See:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../components/nav-link",children:(0,r.jsx)(n.code,{children:"NavLink"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../hooks/use-match",children:(0,r.jsx)(n.code,{children:"useMatch"})})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"relative-links",children:"Relative Links"}),"\n",(0,r.jsxs)(n.p,{children:["Like HTML ",(0,r.jsx)(n.code,{children:"<a href>"}),", ",(0,r.jsx)(n.code,{children:"<Link to>"})," and ",(0,r.jsx)(n.code,{children:"<NavLink to>"})," can take relative paths, with enhanced behavior with nested routes."]}),"\n",(0,r.jsx)(n.p,{children:"Given the following route config:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Route path="home" element={<Home />}>\n  <Route path="project/:projectId" element={<Project />}>\n    <Route path=":taskId" element={<Task />} />\n  </Route>\n</Route>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Consider the url ",(0,r.jsx)(n.a,{href:"https://example.com/home/project/123",children:"https://example.com/home/project/123"}),", which renders the following route component hierarchy:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"<Home>\n  <Project />\n</Home>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"<Project />"})," renders the following links, the hrefs of the links will resolve like so:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.th,{children:["In ",(0,r.jsx)(n.code,{children:"<Project>"})," @ ",(0,r.jsx)(n.code,{children:"/home/project/123"})]}),(0,r.jsxs)(n.th,{children:["Resolved ",(0,r.jsx)(n.code,{children:"<a href>"})]})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:'<Link to="abc">'})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/home/project/123/abc"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:'<Link to=".">'})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/home/project/123"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:'<Link to="..">'})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/home"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:'<Link to=".." relative="path">'})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/home/project"})})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["Note that the first ",(0,r.jsx)(n.code,{children:".."})," removes both segments of the ",(0,r.jsx)(n.code,{children:"project/:projectId"})," route. By default, the ",(0,r.jsx)(n.code,{children:".."})," in relative links traverse the route hierarchy, not the URL segments. Adding ",(0,r.jsx)(n.code,{children:'relative="path"'})," in the next example allows you to traverse the path segments instead."]}),"\n",(0,r.jsxs)(n.p,{children:["Relative links are always relative to the route path they are ",(0,r.jsx)(n.em,{children:"rendered in"}),", not to the full URL. That means if the user navigates deeper with ",(0,r.jsx)(n.code,{children:'<Link to="abc">'})," to ",(0,r.jsx)(n.code,{children:"<Task />"})," at the URL ",(0,r.jsx)(n.code,{children:"/home/project/123/abc"}),", the hrefs in ",(0,r.jsx)(n.code,{children:"<Project>"})," will not change (contrary to plain ",(0,r.jsx)(n.code,{children:"<a href>"}),", a common problem with client side routers)."]}),"\n",(0,r.jsx)(n.h2,{id:"data-loading",children:"Data Loading"}),"\n",(0,r.jsx)(n.p,{children:"Because URL segments usually map to your app's persistent data, React Router provides conventional data loading hooks to initiate data loading during a navigation. Combined with nested routes, all of the data for multiple layouts at a specific URL can be loaded in parallel."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Route\n  path="/"\n  loader={async ({ request }) => {\n    // loaders can be async functions\n    const res = await fetch("/api/user.json", {\n      signal: request.signal,\n    });\n    const user = await res.json();\n    return user;\n  }}\n  element={<Root />}\n>\n  <Route\n    path=":teamId"\n    // loaders understand Fetch Responses and will automatically\n    // unwrap the res.json(), so you can simply return a fetch\n    loader={({ params }) => {\n      return fetch(`/api/teams/${params.teamId}`);\n    }}\n    element={<Team />}\n  >\n    <Route\n      path=":gameId"\n      loader={({ params }) => {\n        // of course you can use any data store\n        return fakeSdk.getTeam(params.gameId);\n      }}\n      element={<Game />}\n    />\n  </Route>\n</Route>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Data is made available to your components through ",(0,r.jsx)(n.code,{children:"useLoaderData"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'function Root() {\n  const user = useLoaderData();\n  // data from <Route path="/">\n}\n\nfunction Team() {\n  const team = useLoaderData();\n  // data from <Route path=":teamId">\n}\n\nfunction Game() {\n  const game = useLoaderData();\n  // data from <Route path=":gameId">\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["When the user visits or clicks links to ",(0,r.jsx)(n.a,{href:"https://example.com/real-salt-lake/45face3",children:"https://example.com/real-salt-lake/45face3"}),", all three route loaders will be called and loaded in parallel, before the UI for that URL renders."]}),"\n",(0,r.jsx)(n.h2,{id:"redirects",children:"Redirects"}),"\n",(0,r.jsxs)(n.p,{children:["While loading or changing data, it's common to ",(0,r.jsx)(n.a,{href:"../fetch/redirect",children:"redirect"})," the user to a different route."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Route\n  path="dashboard"\n  loader={async () => {\n    const user = await fake.getUser();\n    if (!user) {\n      // if you know you can\'t render the route, you can\n      // throw a redirect to stop executing code here,\n      // sending the user to a new route\n      throw redirect("/login");\n    }\n\n    // otherwise continue\n    const stats = await fake.getDashboardStats();\n    return { user, stats };\n  }}\n/>\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Route\n  path="project/new"\n  action={async ({ request }) => {\n    const data = await request.formData();\n    const newProject = await createProject(data);\n    // it\'s common to redirect after actions complete,\n    // sending the user to the new record\n    return redirect(`/projects/${newProject.id}`);\n  }}\n/>\n'})}),"\n",(0,r.jsx)(n.p,{children:"See:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../fetch/redirect",children:(0,r.jsx)(n.code,{children:"redirect"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../route/loader#throwing-in-loaders",children:"Throwing in Loaders"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../hooks/use-navigate",children:(0,r.jsx)(n.code,{children:"useNavigate"})})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"pending-navigation-ui",children:"Pending Navigation UI"}),"\n",(0,r.jsx)(n.p,{children:"When users navigate around the app, the data for the next page is loaded before the page is rendered. It's important to provide user feedback during this time so the app doesn't feel like it's unresponsive."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:"lines=[2,5]",children:'function Root() {\n  const navigation = useNavigation();\n  return (\n    <div>\n      {navigation.state === "loading" && <GlobalSpinner />}\n      <FakeSidebar />\n      <Outlet />\n      <FakeFooter />\n    </div>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"See:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../hooks/use-navigation",children:(0,r.jsx)(n.code,{children:"useNavigation"})})}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"skeleton-ui-with-suspense",children:["Skeleton UI with ",(0,r.jsx)(n.code,{children:"<Suspense>"})]}),"\n",(0,r.jsxs)(n.p,{children:["Instead of waiting for the data for the next page, you can ",(0,r.jsx)(n.a,{href:"../utils/defer",children:(0,r.jsx)(n.code,{children:"defer"})})," data so the UI flips over to the next screen with placeholder UI immediately while the data loads."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:"lines=[12,22-29,32-35,42]",children:'<Route\n  path="issue/:issueId"\n  element={<Issue />}\n  loader={async ({ params }) => {\n    // these are promises, but *not* awaited\n    const comments = fake.getIssueComments(params.issueId);\n    const history = fake.getIssueHistory(params.issueId);\n    // the issue, however, *is* awaited\n    const issue = await fake.getIssue(params.issueId);\n\n    // defer enables suspense for the un-awaited promises\n    return defer({ issue, comments, history });\n  }}\n/>;\n\nfunction Issue() {\n  const { issue, history, comments } = useLoaderData();\n  return (\n    <div>\n      <IssueDescription issue={issue} />\n\n      {/* Suspense provides the placeholder fallback */}\n      <Suspense fallback={<IssueHistorySkeleton />}>\n        {/* Await manages the deferred data (promise) */}\n        <Await resolve={history}>\n          {/* this calls back when the data is resolved */}\n          {(resolvedHistory) => (\n            <IssueHistory history={resolvedHistory} />\n          )}\n        </Await>\n      </Suspense>\n\n      <Suspense fallback={<IssueCommentsSkeleton />}>\n        <Await resolve={comments}>\n          {/* ... or you can use hooks to access the data */}\n          <IssueComments />\n        </Await>\n      </Suspense>\n    </div>\n  );\n}\n\nfunction IssueComments() {\n  const comments = useAsyncValue();\n  return <div>{/* ... */}</div>;\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"See"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../guides/deferred",children:"Deferred Data Guide"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../utils/defer",children:(0,r.jsx)(n.code,{children:"defer"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../components/await",children:(0,r.jsx)(n.code,{children:"Await"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../hooks/use-async-value",children:(0,r.jsx)(n.code,{children:"useAsyncValue"})})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"data-mutations",children:"Data Mutations"}),"\n",(0,r.jsx)(n.p,{children:"HTML forms are navigation events, just like links. React Router supports HTML form workflows with client side routing."}),"\n",(0,r.jsxs)(n.p,{children:["When a form is submitted, the normal browser navigation event is prevented and a ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Request",children:(0,r.jsx)(n.code,{children:"Request"})}),", with a body containing the ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/FormData",children:(0,r.jsx)(n.code,{children:"FormData"})})," of the submission, is created. This request is sent to the ",(0,r.jsx)(n.code,{children:"<Route action>"})," that matches the form's ",(0,r.jsx)(n.code,{children:"<Form action>"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Form elements's ",(0,r.jsx)(n.code,{children:"name"})," prop are submitted to the action:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Form action="/project/new">\n  <label>\n    Project title\n    <br />\n    <input type="text" name="title" />\n  </label>\n\n  <label>\n    Target Finish Date\n    <br />\n    <input type="date" name="due" />\n  </label>\n</Form>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The normal HTML document request is prevented and sent to the matching route's action (",(0,r.jsx)(n.code,{children:"<Route path>"})," that matches the ",(0,r.jsx)(n.code,{children:"<form action>"}),"), including the ",(0,r.jsx)(n.code,{children:"request.formData"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Route\n  path="project/new"\n  action={async ({ request }) => {\n    const formData = await request.formData();\n    const newProject = await createProject({\n      title: formData.get("title"),\n      due: formData.get("due"),\n    });\n    return redirect(`/projects/${newProject.id}`);\n  }}\n/>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"data-revalidation",children:"Data Revalidation"}),"\n",(0,r.jsx)(n.p,{children:"Decades old web conventions indicate that when a form is posted to the server, data is changing and a new page is rendered. That convention is followed in React Router's HTML-based data mutation APIs."}),"\n",(0,r.jsx)(n.p,{children:"After route actions are called, the loaders for all of the data on the page is called again to ensure the UI stays up-to-date with the data automatically. No cache keys to expire, no context providers to reload."}),"\n",(0,r.jsx)(n.p,{children:"See:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../start/tutorial#creating-contacts",children:'Tutorial "Creating Contacts"'})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"busy-indicators",children:"Busy Indicators"}),"\n",(0,r.jsx)(n.p,{children:"When forms are being submitted to route actions, you have access to the navigation state to display busy indicators, disable fieldsets, etc."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:"lines=[2,3,6,19-21]",children:'function NewProjectForm() {\n  const navigation = useNavigation();\n  const busy = navigation.state === "submitting";\n  return (\n    <Form action="/project/new">\n      <fieldset disabled={busy}>\n        <label>\n          Project title\n          <br />\n          <input type="text" name="title" />\n        </label>\n\n        <label>\n          Target Finish Date\n          <br />\n          <input type="date" name="due" />\n        </label>\n      </fieldset>\n      <button type="submit" disabled={busy}>\n        {busy ? "Creating..." : "Create"}\n      </button>\n    </Form>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"See:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../hooks/use-navigation",children:(0,r.jsx)(n.code,{children:"useNavigation"})})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"optimistic-ui",children:"Optimistic UI"}),"\n",(0,r.jsxs)(n.p,{children:["Knowing the ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/FormData",children:(0,r.jsx)(n.code,{children:"formData"})})," being sent to an ",(0,r.jsx)(n.a,{href:"../route/action",children:"action"}),' is often enough to skip the busy indicators and render the UI in the next state immediately, even if your asynchronous work is still pending. This is called "optimistic UI".']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'function LikeButton({ tweet }) {\n  const fetcher = useFetcher();\n\n  // if there is `formData` then it is posting to the action\n  const liked = fetcher.formData\n    ? // check the formData to be optimistic\n      fetcher.formData.get("liked") === "yes"\n    : // if its not posting to the action, use the record\'s value\n      tweet.liked;\n\n  return (\n    <fetcher.Form method="post" action="toggle-liked">\n      <button\n        type="submit"\n        name="liked"\n        value={liked ? "yes" : "no"}\n      />\n    </fetcher.Form>\n  );\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["(Yes, HTML buttons can have a ",(0,r.jsx)(n.code,{children:"name"})," and a ",(0,r.jsx)(n.code,{children:"value"}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["While it is more common to do optimistic UI with a ",(0,r.jsx)(n.a,{href:"../hooks/use-fetcher",children:(0,r.jsx)(n.code,{children:"fetcher"})}),", you can do the same with a normal form using ",(0,r.jsx)(n.a,{href:"../hooks/use-navigation#navigationformdata",children:(0,r.jsx)(n.code,{children:"navigation.formData"})}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"data-fetchers",children:"Data Fetchers"}),"\n",(0,r.jsx)(n.p,{children:"HTML Forms are the model for mutations but they have one major limitation: you can have only one at a time because a form submission is a navigation."}),"\n",(0,r.jsx)(n.p,{children:"Most web apps need to allow for multiple mutations to be happening at the same time, like a list of records where each can be independently deleted, marked complete, liked, etc."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"../hooks/use-fetcher",children:"Fetchers"})," allow you to interact with the route ",(0,r.jsx)(n.a,{href:"../route/action",children:"actions"})," and ",(0,r.jsx)(n.a,{href:"../route/loader",children:"loaders"})," without causing a navigation in the browser, but still getting all the conventional benefits like error handling, revalidation, interruption handling, and race condition handling."]}),"\n",(0,r.jsx)(n.p,{children:"Imagine a list of tasks:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"function Tasks() {\n  const tasks = useLoaderData();\n  return tasks.map((task) => (\n    <div>\n      <p>{task.name}</p>\n      <ToggleCompleteButton task={task} />\n    </div>\n  ));\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Each task can be marked complete independently of the rest, with its own pending state and without causing a navigation with a ",(0,r.jsx)(n.a,{href:"../hooks/use-fetcher",children:"fetcher"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'function ToggleCompleteButton({ task }) {\n  const fetcher = useFetcher();\n\n  return (\n    <fetcher.Form method="post" action="/toggle-complete">\n      <fieldset disabled={fetcher.state !== "idle"}>\n        <input type="hidden" name="id" value={task.id} />\n        <input\n          type="hidden"\n          name="status"\n          value={task.complete ? "incomplete" : "complete"}\n        />\n        <button type="submit">\n          {task.status === "complete"\n            ? "Mark Incomplete"\n            : "Mark Complete"}\n        </button>\n      </fieldset>\n    </fetcher.Form>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"See:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../hooks/use-fetcher",children:(0,r.jsx)(n.code,{children:"useFetcher"})})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"race-condition-handling",children:"Race Condition Handling"}),"\n",(0,r.jsx)(n.p,{children:"React Router will cancel stale operations and only commit fresh data automatically."}),"\n",(0,r.jsx)(n.p,{children:"Any time you have asynchronous UI you have the risk of race conditions: when an async operation starts after but completes before an earlier operation. The result is a user interface that shows the wrong state."}),"\n",(0,r.jsx)(n.p,{children:"Consider a search field that updates a list as the user types:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"?q=ry    |---------------|\n                         ^ commit wrong state\n?q=ryan     |--------|\n                     ^ lose correct state\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Even though the query for ",(0,r.jsx)(n.code,{children:"q?=ryan"})," went out later, it completed earlier. If not handled correctly, the results will briefly be the correct values for ",(0,r.jsx)(n.code,{children:"?q=ryan"})," but then flip over the incorrect results for ",(0,r.jsx)(n.code,{children:"?q=ry"}),". Throttling and debouncing are not enough (you can still interrupt the requests that get through). You need cancellation."]}),"\n",(0,r.jsx)(n.p,{children:"If you're using React Router's data conventions you avoid this problem completely and automatically."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"?q=ry    |-----------X\n                     ^ cancel wrong state when\n                       correct state completes earlier\n?q=ryan     |--------|\n                     ^ commit correct state\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Not only does React Router handle race conditions for a navigation like this, it also handles it for many other cases like loading results for an autocomplete or performing multiple concurrent mutations with ",(0,r.jsx)(n.a,{href:"../hooks/use-fetcher",children:(0,r.jsx)(n.code,{children:"fetcher"})})," (and its automatic, concurrent revalidations)."]}),"\n",(0,r.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.p,{children:"The vast majority of your application errors are handled automatically by React Router. It will catch any errors that are thrown while:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"rendering"}),"\n",(0,r.jsx)(n.li,{children:"loading data"}),"\n",(0,r.jsx)(n.li,{children:"updating data"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["In practice, this is pretty much every error in your app except those thrown in event handlers (",(0,r.jsx)(n.code,{children:"<button onClick>"}),") or ",(0,r.jsx)(n.code,{children:"useEffect"}),". React Router apps tend to have very few of either."]}),"\n",(0,r.jsxs)(n.p,{children:["When an error is thrown, instead of rendering the route's ",(0,r.jsx)(n.a,{href:"../route/route#element",children:(0,r.jsx)(n.code,{children:"element"})}),", the ",(0,r.jsx)(n.a,{href:"../route/error-element",children:(0,r.jsx)(n.code,{children:"errorElement"})})," is rendered."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Route\n  path="/"\n  loader={() => {\n    something.that.throws.an.error();\n  }}\n  // this will not be rendered\n  element={<HappyPath />}\n  // but this will instead\n  errorElement={<ErrorBoundary />}\n/>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["If a route doesn't have an ",(0,r.jsx)(n.code,{children:"errorElement"}),", the error will bubble to the nearest parent route with an ",(0,r.jsx)(n.code,{children:"errorElement"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Route\n  path="/"\n  element={<HappyPath />}\n  errorElement={<ErrorBoundary />}\n>\n  {/* Errors here bubble up to the parent route */}\n  <Route path="login" element={<Login />} />\n</Route>\n'})}),"\n",(0,r.jsx)(n.p,{children:"See:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../route/error-element",children:(0,r.jsx)(n.code,{children:"<Route errorElement>"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../hooks/use-route-error",children:(0,r.jsx)(n.code,{children:"useRouteError"})})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"scroll-restoration",children:"Scroll Restoration"}),"\n",(0,r.jsx)(n.p,{children:"React Router will emulate the browser's scroll restoration on navigation, waiting for data to load before scrolling. This ensures the scroll position is restored to the right spot."}),"\n",(0,r.jsx)(n.p,{children:"You can also customize the behavior by restoring based on something other than locations (like a url pathname) and preventing the scroll from happening on certain links (like tabs in the middle of a page)."}),"\n",(0,r.jsx)(n.p,{children:"See:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../components/scroll-restoration",children:(0,r.jsx)(n.code,{children:"<ScrollRestoration>"})})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"web-standard-apis",children:"Web Standard APIs"}),"\n",(0,r.jsxs)(n.p,{children:["React Router is built on web standard APIs. ",(0,r.jsx)(n.a,{href:"../route/loader",children:"Loaders"})," and ",(0,r.jsx)(n.a,{href:"../route/action",children:"actions"})," receive standard Web Fetch API ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Request",children:(0,r.jsx)(n.code,{children:"Request"})})," objects and can return ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Response",children:(0,r.jsx)(n.code,{children:"Response"})})," objects, too. Cancellation is done with ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal",children:"Abort Signals"}),", search params are handled with ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams",children:(0,r.jsx)(n.code,{children:"URLSearchParams"})}),", and data mutations are handled with ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form",children:"HTML Forms"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"When you get better at React Router, you get better at the web platform."}),"\n",(0,r.jsx)(n.h2,{id:"search-params",children:"Search Params"}),"\n",(0,r.jsx)("docs-info",{children:"TODO:"}),"\n",(0,r.jsx)(n.h2,{id:"location-state",children:"Location State"}),"\n",(0,r.jsx)("docs-info",{children:"TODO:"})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>i});var r=t(7294);const s={},a=r.createContext(s);function i(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);