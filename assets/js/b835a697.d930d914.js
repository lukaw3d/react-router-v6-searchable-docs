"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[888],{8755:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var o=t(5893),r=t(1151);const a={title:"action",new:!0,sidebar_position:void 0},s="action",i={id:"route/action",title:"action",description:'Route actions are the "writes" to route loader "reads". They provide a way for apps to perform data mutations with simple HTML and HTTP semantics while React Router abstracts away the complexity of asynchronous UI and revalidation. This gives you the simple mental model of HTML + HTTP (where the browser handles the asynchrony and revalidation) with the behavior and UX capabilities of modern SPAs.',source:"@site/react-router/docs/route/action.md",sourceDirName:"route",slug:"/route/action",permalink:"/react-router-v6-searchable-docs/route/action",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1696362989,formattedLastUpdatedAt:"Oct 3, 2023",frontMatter:{title:"action",new:!0},sidebar:"tutorialSidebar",previous:{title:"Route",permalink:"/react-router-v6-searchable-docs/route/"},next:{title:"errorElement",permalink:"/react-router-v6-searchable-docs/route/error-element"}},d={},c=[{value:"<code>params</code>",id:"params",level:2},{value:"<code>request</code>",id:"request",level:2},{value:"Opt-in serialization types",id:"opt-in-serialization-types",level:3},{value:"Returning Responses",id:"returning-responses",level:2},{value:"Throwing in Actions",id:"throwing-in-actions",level:2},{value:"Handling multiple actions per route",id:"handling-multiple-actions-per-route",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"action",children:(0,o.jsx)(n.code,{children:"action"})}),"\n",(0,o.jsxs)(n.p,{children:['Route actions are the "writes" to route ',(0,o.jsx)(n.a,{href:"./loader",children:"loader"}),' "reads". They provide a way for apps to perform data mutations with simple HTML and HTTP semantics while React Router abstracts away the complexity of asynchronous UI and revalidation. This gives you the simple mental model of HTML + HTTP (where the browser handles the asynchrony and revalidation) with the behavior and UX capabilities of modern SPAs.']}),"\n",(0,o.jsxs)("docs-warning",{children:["This feature only works if using a data router, see ",(0,o.jsx)(n.a,{href:"../routers/picking-a-router",children:"Picking a Router"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'<Route\n  path="/song/:songId/edit"\n  element={<EditSong />}\n  action={async ({ params, request }) => {\n    let formData = await request.formData();\n    return fakeUpdateSong(params.songId, formData);\n  }}\n  loader={({ params }) => {\n    return fakeGetSong(params.songId);\n  }}\n/>\n'})}),"\n",(0,o.jsx)(n.p,{children:'Actions are called whenever the app sends a non-get submission ("post", "put", "patch", "delete") to your route. This can happen in a few ways:'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'// forms\n<Form method="post" action="/songs" />;\n<fetcher.Form method="put" action="/songs/123/edit" />;\n\n// imperative submissions\nlet submit = useSubmit();\nsubmit(data, {\n  method: "delete",\n  action: "/songs/123",\n});\nfetcher.submit(data, {\n  method: "patch",\n  action: "/songs/123/edit",\n});\n'})}),"\n",(0,o.jsx)(n.h2,{id:"params",children:(0,o.jsx)(n.code,{children:"params"})}),"\n",(0,o.jsxs)(n.p,{children:["Route params are parsed from ",(0,o.jsx)(n.a,{href:"./route#dynamic-segments",children:"dynamic segments"})," and passed to your action. This is useful for figuring out which resource to mutate:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'<Route\n  path="/projects/:projectId/delete"\n  action={({ params }) => {\n    return fakeDeleteProject(params.projectId);\n  }}\n/>\n'})}),"\n",(0,o.jsx)(n.h2,{id:"request",children:(0,o.jsx)(n.code,{children:"request"})}),"\n",(0,o.jsxs)(n.p,{children:["This is a ",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Request",children:"Fetch Request"})," instance being sent to your route. The most common use case is to parse the ",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/FormData",children:"FormData"})," from the request"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"<Route\n  action={async ({ request }) => {\n    let formData = await request.formData();\n    // ...\n  }}\n/>\n"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"A Request?!"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:'It might seem odd at first that actions receive a "request". Have you ever written this line of code?'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",metastring:"[3]",children:"<form\n  onSubmit={(event) => {\n    event.preventDefault();\n    // ...\n  }}\n/>\n"})}),"\n",(0,o.jsx)(n.p,{children:"What exactly are you preventing?"}),"\n",(0,o.jsxs)(n.p,{children:["Without JavaScript, just plain HTML and an HTTP web server, that default event that was prevented is actually pretty great. Browsers will serialize all the data in the form into ",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/FormData",children:(0,o.jsx)(n.code,{children:"FormData"})})," and send it as the body of a new request to your server. Like the code above, React Router ",(0,o.jsx)(n.a,{href:"../components/form",children:(0,o.jsx)(n.code,{children:"<Form>"})})," prevents the browser from sending that request and instead sends the request to your route action! This enables highly dynamic web apps with the simple model of HTML and HTTP."]}),"\n",(0,o.jsxs)(n.p,{children:["Remember that the values in the ",(0,o.jsx)(n.code,{children:"formData"})," are automatically serialized from the form submission, so your inputs need a ",(0,o.jsx)(n.code,{children:"name"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'<Form method="post">\n  <input name="songTitle" />\n  <textarea name="lyrics" />\n  <button type="submit">Save</button>\n</Form>;\n\n// accessed by the same names\nformData.get("songTitle");\nformData.get("lyrics");\n'})}),"\n",(0,o.jsxs)(n.p,{children:["For more information on ",(0,o.jsx)(n.code,{children:"formData"})," see ",(0,o.jsx)(n.a,{href:"../guides/form-data",children:"Working with FormData"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"opt-in-serialization-types",children:"Opt-in serialization types"}),"\n",(0,o.jsxs)(n.p,{children:["Note that when using ",(0,o.jsx)(n.a,{href:"../hooks/use-submit",children:(0,o.jsx)(n.code,{children:"useSubmit"})})," you may also pass ",(0,o.jsx)(n.code,{children:'encType: "application/json"'})," or ",(0,o.jsx)(n.code,{children:'encType: "text/plain"'})," to instead serialize your payload into ",(0,o.jsx)(n.code,{children:"request.json()"})," or ",(0,o.jsx)(n.code,{children:"request.text()"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"returning-responses",children:"Returning Responses"}),"\n",(0,o.jsxs)(n.p,{children:["While you can return anything you want from an action and get access to it from ",(0,o.jsx)(n.a,{href:"../hooks/use-action-data",children:(0,o.jsx)(n.code,{children:"useActionData"})}),", you can also return a web ",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Response",children:"Response"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["For more information, see the ",(0,o.jsx)(n.a,{href:"./loader#returning-responses",children:"loader documentation"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"throwing-in-actions",children:"Throwing in Actions"}),"\n",(0,o.jsxs)(n.p,{children:["You can ",(0,o.jsx)(n.code,{children:"throw"}),' in your action to break out of the current call stack (stop running the current code) and React Router will start over down the "error path".']}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",metastring:"[10]",children:'<Route\n  action={async ({ params, request }) => {\n    const res = await fetch(\n      `/api/properties/${params.id}`,\n      {\n        method: "put",\n        body: await request.formData(),\n      }\n    );\n    if (!res.ok) throw res;\n    return { ok: true };\n  }}\n/>\n'})}),"\n",(0,o.jsxs)(n.p,{children:["For more details and expanded use cases, read the ",(0,o.jsx)(n.a,{href:"./error-element",children:"errorElement"})," documentation."]}),"\n",(0,o.jsx)(n.h2,{id:"handling-multiple-actions-per-route",children:"Handling multiple actions per route"}),"\n",(0,o.jsxs)(n.p,{children:["A fairly common question that pops up is ",(0,o.jsx)(n.em,{children:'"What if I need to handle multiple different behaviors in my action?"'})," There's a few ways to accomplish this, but usually the simplest is to put a ",(0,o.jsx)(n.code,{children:"name"}),"/",(0,o.jsx)(n.code,{children:"value"})," on your ",(0,o.jsx)(n.code,{children:'<button type="submit">'})," and use that in the action to decide which code to execute (that's right - submitting ",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button",children:"buttons"})," can have name/value attributes!):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",metastring:"lines=[3,5,10,30-32,42-44]",children:'async function action({ request }) {\n  let formData = await request.formData();\n  let intent = formData.get("intent");\n\n  if (intent === "edit") {\n    await editSong(formData);\n    return { ok: true };\n  }\n\n  if (intent === "add") {\n    await addSong(formData);\n    return { ok: true };\n  }\n\n  throw json(\n    { message: "Invalid intent" },\n    { status: 400 }\n  );\n}\n\nfunction Component() {\n  let song = useLoaderData();\n\n  // When the song exists, show an edit form\n  if (song) {\n    return (\n      <Form method="post">\n        <p>Edit song lyrics:</p>\n        {/* Edit song inputs */}\n        <button type="submit" name="intent" value="edit">\n          Edit\n        </button>\n      </Form>\n    );\n  }\n\n  // Otherwise show a form to add a new song\n  return (\n    <Form method="post">\n      <p>Add new lyrics:</p>\n      {/* Add song inputs */}\n      <button type="submit" name="intent" value="add">\n        Add\n      </button>\n    </Form>\n  );\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["If a button name/value isn't right for your use case, you could also use a hidden input to send and ",(0,o.jsx)(n.code,{children:"intent"})," or you could submit different HTTP methods via the ",(0,o.jsx)(n.a,{href:"../components/form#method",children:(0,o.jsx)(n.code,{children:"<Form method>"})})," prop (",(0,o.jsx)(n.code,{children:"POST"})," for add, ",(0,o.jsx)(n.code,{children:"PUT"}),"/",(0,o.jsx)(n.code,{children:"PATCH"})," for edit, ",(0,o.jsx)(n.code,{children:"DELETE"})," for remove)."]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>s});var o=t(7294);const r={},a=o.createContext(r);function s(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);