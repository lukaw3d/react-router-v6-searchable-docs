"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1859],{5451:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>s,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>l});var t=o(5893),r=o(1151);const c={title:"useBlocker",sidebar_position:void 0},a="useBlocker",i={id:"hooks/use-blocker",title:"useBlocker",description:"Type declaration",source:"@site/react-router/docs/hooks/use-blocker.md",sourceDirName:"hooks",slug:"/hooks/use-blocker",permalink:"/react-router-v6-searchable-docs/hooks/use-blocker",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1699022390,formattedLastUpdatedAt:"Nov 3, 2023",frontMatter:{title:"useBlocker"},sidebar:"tutorialSidebar",previous:{title:"useBeforeUnload",permalink:"/react-router-v6-searchable-docs/hooks/use-before-unload"},next:{title:"useFetcher",permalink:"/react-router-v6-searchable-docs/hooks/use-fetcher"}},s={},l=[{value:"Properties",id:"properties",level:2},{value:"<code>state</code>",id:"state",level:3},{value:"<code>location</code>",id:"location",level:3},{value:"Methods",id:"methods",level:2},{value:"<code>proceed()</code>",id:"proceed",level:3},{value:"<code>reset()</code>",id:"reset",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components},{Details:o}=n;return o||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"useblocker",children:(0,t.jsx)(n.code,{children:"useBlocker"})}),"\n",(0,t.jsxs)(o,{children:[(0,t.jsx)("summary",{children:"Type declaration"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'declare function useBlocker(\n  shouldBlock: boolean | BlockerFunction\n): Blocker;\n\ntype BlockerFunction = (args: {\n  currentLocation: Location;\n  nextLocation: Location;\n  historyAction: HistoryAction;\n}) => boolean;\n\ntype Blocker =\n  | {\n      state: "unblocked";\n      reset: undefined;\n      proceed: undefined;\n      location: undefined;\n    }\n  | {\n      state: "blocked";\n      reset(): void;\n      proceed(): void;\n      location: Location;\n    }\n  | {\n      state: "proceeding";\n      reset: undefined;\n      proceed: undefined;\n      location: Location;\n    };\n\ninterface Location<State = any> extends Path {\n  state: State;\n  key: string;\n}\n\ninterface Path {\n  pathname: string;\n  search: string;\n  hash: string;\n}\n\nenum HistoryAction {\n  Pop = "POP",\n  Push = "PUSH",\n  Replace = "REPLACE",\n}\n'})})]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"useBlocker"})," hook allows you to prevent the user from navigating away from the current location, and present them with a custom UI to allow them to confirm the navigation."]}),"\n",(0,t.jsx)("docs-info",{children:(0,t.jsxs)(n.p,{children:["This only works for client-side navigations within your React Router application and will not block document requests. To prevent document navigations you will need to add your own ",(0,t.jsx)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event",target:"_blank",children:(0,t.jsx)(n.code,{children:"beforeunload"})})," event handler."]})}),"\n",(0,t.jsx)("docs-warning",{children:(0,t.jsxs)(n.p,{children:["Blocking a user from navigating is a bit of an anti-pattern, so please carefully consider any usage of this hook and use it sparingly. In the de-facto use case of preventing a user navigating away from a half-filled form, you might consider persisting unsaved state to ",(0,t.jsx)(n.code,{children:"sessionStorage"})," and automatically re-filling it if they return instead of blocking them from navigating away."]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'function ImportantForm() {\n  let [value, setValue] = React.useState("");\n\n  // Block navigating elsewhere when data has been entered into the input\n  let blocker = useBlocker(\n    ({ currentLocation, nextLocation }) =>\n      value !== "" &&\n      currentLocation.pathname !== nextLocation.pathname\n  );\n\n  return (\n    <Form method="post">\n      <label>\n        Enter some important data:\n        <input\n          name="data"\n          value={value}\n          onChange={(e) => setValue(e.target.value)}\n        />\n      </label>\n      <button type="submit">Save</button>\n\n      {blocker.state === "blocked" ? (\n        <div>\n          <p>Are you sure you want to leave?</p>\n          <button onClick={() => blocker.proceed()}>\n            Proceed\n          </button>\n          <button onClick={() => blocker.reset()}>\n            Cancel\n          </button>\n        </div>\n      ) : null}\n    </Form>\n  );\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["For a more complete example, please refer to the ",(0,t.jsx)(n.a,{href:"https://github.com/remix-run/react-router/tree/main/examples/navigation-blocking",children:"example"})," in the repository."]}),"\n",(0,t.jsx)(n.h2,{id:"properties",children:"Properties"}),"\n",(0,t.jsx)(n.h3,{id:"state",children:(0,t.jsx)(n.code,{children:"state"})}),"\n",(0,t.jsx)(n.p,{children:"The current state of the blocker"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"unblocked"})," - the blocker is idle and has not prevented any navigation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"blocked"})," - the blocker has prevented a navigation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"proceeding"})," - the blocker is proceeding through from a blocked navigation"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"location",children:(0,t.jsx)(n.code,{children:"location"})}),"\n",(0,t.jsxs)(n.p,{children:["When in a ",(0,t.jsx)(n.code,{children:"blocked"})," state, this represents the location to which we blocked a navigation. When in a ",(0,t.jsx)(n.code,{children:"proceeding"})," state, this is the location being navigated to after a ",(0,t.jsx)(n.code,{children:"blocker.proceed()"})," call."]}),"\n",(0,t.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(n.h3,{id:"proceed",children:(0,t.jsx)(n.code,{children:"proceed()"})}),"\n",(0,t.jsxs)(n.p,{children:["When in a ",(0,t.jsx)(n.code,{children:"blocked"})," state, you may call ",(0,t.jsx)(n.code,{children:"blocker.proceed()"})," to proceed to the blocked location."]}),"\n",(0,t.jsx)(n.h3,{id:"reset",children:(0,t.jsx)(n.code,{children:"reset()"})}),"\n",(0,t.jsxs)(n.p,{children:["When in a ",(0,t.jsx)(n.code,{children:"blocked"})," state, you may call ",(0,t.jsx)(n.code,{children:"blocker.reset()"})," to return the blocker back to an ",(0,t.jsx)(n.code,{children:"unblocked"})," state and leave the user at the current location."]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},1151:(e,n,o)=>{o.d(n,{Z:()=>i,a:()=>a});var t=o(7294);const r={},c=t.createContext(r);function a(e){const n=t.useContext(c);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(c.Provider,{value:n},e.children)}}}]);